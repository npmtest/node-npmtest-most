{"/home/travis/build/npmtest/node-npmtest-most/test.js":"/* istanbul instrument in package npmtest_most */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-most/lib.npmtest_most.js":"/* istanbul instrument in package npmtest_most */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_most = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_most = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-most/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-most && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_most */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_most\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_most.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_most.rollup.js'] =\n            local.assetsDict['/assets.npmtest_most.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_most.__dirname + '/lib.npmtest_most.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PropagateTask = exports.defaultScheduler = exports.multicast = exports.throwError = exports.flatMapError = exports.recoverWith = exports.await = exports.awaitPromises = exports.fromPromise = exports.debounce = exports.throttle = exports.timestamp = exports.delay = exports.during = exports.since = exports.skipUntil = exports.until = exports.takeUntil = exports.skipWhile = exports.takeWhile = exports.slice = exports.skip = exports.take = exports.distinctBy = exports.skipRepeatsWith = exports.distinct = exports.skipRepeats = exports.filter = exports.switch = exports.switchLatest = exports.zipArray = exports.zip = exports.sampleWith = exports.sampleArray = exports.sample = exports.combineArray = exports.combine = exports.mergeArray = exports.merge = exports.mergeConcurrently = exports.concatMap = exports.flatMapEnd = exports.continueWith = exports.join = exports.chain = exports.flatMap = exports.transduce = exports.ap = exports.tap = exports.constant = exports.map = exports.startWith = exports.concat = exports.generate = exports.iterate = exports.unfold = exports.reduce = exports.scan = exports.loop = exports.drain = exports.forEach = exports.observe = exports.fromEvent = exports.periodic = exports.from = exports.never = exports.empty = exports.just = exports.of = exports.Stream = undefined;\n\nvar _fromEvent = require('./source/fromEvent');\n\nObject.defineProperty(exports, 'fromEvent', {\n  enumerable: true,\n  get: function () {\n    return _fromEvent.fromEvent;\n  }\n});\n\nvar _unfold = require('./source/unfold');\n\nObject.defineProperty(exports, 'unfold', {\n  enumerable: true,\n  get: function () {\n    return _unfold.unfold;\n  }\n});\n\nvar _iterate = require('./source/iterate');\n\nObject.defineProperty(exports, 'iterate', {\n  enumerable: true,\n  get: function () {\n    return _iterate.iterate;\n  }\n});\n\nvar _generate = require('./source/generate');\n\nObject.defineProperty(exports, 'generate', {\n  enumerable: true,\n  get: function () {\n    return _generate.generate;\n  }\n});\n\nvar _Stream = require('./Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nvar _core = require('./source/core');\n\nvar _from = require('./source/from');\n\nvar _periodic = require('./source/periodic');\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nvar _subscribe = require('./observable/subscribe');\n\nvar _thru = require('./combinator/thru');\n\nvar _observe = require('./combinator/observe');\n\nvar _loop = require('./combinator/loop');\n\nvar _accumulate = require('./combinator/accumulate');\n\nvar _build = require('./combinator/build');\n\nvar _transform = require('./combinator/transform');\n\nvar _applicative = require('./combinator/applicative');\n\nvar _transduce = require('./combinator/transduce');\n\nvar _flatMap = require('./combinator/flatMap');\n\nvar _continueWith = require('./combinator/continueWith');\n\nvar _concatMap = require('./combinator/concatMap');\n\nvar _mergeConcurrently = require('./combinator/mergeConcurrently');\n\nvar _merge = require('./combinator/merge');\n\nvar _combine = require('./combinator/combine');\n\nvar _sample = require('./combinator/sample');\n\nvar _zip = require('./combinator/zip');\n\nvar _switch = require('./combinator/switch');\n\nvar _filter = require('./combinator/filter');\n\nvar _slice = require('./combinator/slice');\n\nvar _timeslice = require('./combinator/timeslice');\n\nvar _delay = require('./combinator/delay');\n\nvar _timestamp = require('./combinator/timestamp');\n\nvar _limit = require('./combinator/limit');\n\nvar _promises = require('./combinator/promises');\n\nvar _errors = require('./combinator/errors');\n\nvar _multicast = require('@most/multicast');\n\nvar _multicast2 = _interopRequireDefault(_multicast);\n\nvar _defaultScheduler = require('./scheduler/defaultScheduler');\n\nvar _defaultScheduler2 = _interopRequireDefault(_defaultScheduler);\n\nvar _PropagateTask = require('./scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Core stream type\n * @type {Stream}\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexports.Stream = _Stream2.default;\n\n// Add of and empty to constructor for fantasy-land compat\n\n_Stream2.default.of = _core.of;\n_Stream2.default.empty = _core.empty;\n// Add from to constructor for ES Observable compat\n_Stream2.default.from = _from.from;\nexports.of = _core.of;\nexports.just = _core.of;\nexports.empty = _core.empty;\nexports.never = _core.never;\nexports.from = _from.from;\nexports.periodic = _periodic.periodic;\n\n// -----------------------------------------------------------------------\n// Draft ES Observable proposal interop\n// https://github.com/zenparsing/es-observable\n\n_Stream2.default.prototype.subscribe = function (subscriber) {\n  return (0, _subscribe.subscribe)(subscriber, this);\n};\n\n_Stream2.default.prototype[_symbolObservable2.default] = function () {\n  return this;\n};\n\n// -----------------------------------------------------------------------\n// Fluent adapter\n\n/**\n * Adapt a functional stream transform to fluent style.\n * It applies f to the this stream object\n * @param  {function(s: Stream): Stream} f function that\n * receives the stream itself and must return a new stream\n * @return {Stream}\n */\n_Stream2.default.prototype.thru = function (f) {\n  return (0, _thru.thru)(f, this);\n};\n\n// -----------------------------------------------------------------------\n// Adapting other sources\n\n/**\n * Create a stream of events from the supplied EventTarget or EventEmitter\n * @param {String} event event name\n * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter. The source\n *  must support either addEventListener/removeEventListener (w3c EventTarget:\n *  http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget),\n *  or addListener/removeListener (node EventEmitter: http://nodejs.org/api/events.html)\n * @returns {Stream} stream of events of the specified type from the source\n */\n\n\n// -----------------------------------------------------------------------\n// Observing\n\nexports.observe = _observe.observe;\nexports.forEach = _observe.observe;\nexports.drain = _observe.drain;\n\n/**\n * Process all the events in the stream\n * @returns {Promise} promise that fulfills when the stream ends, or rejects\n *  if the stream fails with an unhandled error.\n */\n\n_Stream2.default.prototype.observe = _Stream2.default.prototype.forEach = function (f) {\n  return (0, _observe.observe)(f, this);\n};\n\n/**\n * Consume all events in the stream, without providing a function to process each.\n * This causes a stream to become active and begin emitting events, and is useful\n * in cases where all processing has been setup upstream via other combinators, and\n * there is no need to process the terminal events.\n * @returns {Promise} promise that fulfills when the stream ends, or rejects\n *  if the stream fails with an unhandled error.\n */\n_Stream2.default.prototype.drain = function () {\n  return (0, _observe.drain)(this);\n};\n\n// -------------------------------------------------------\n\nexports.loop = _loop.loop;\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\n\n_Stream2.default.prototype.loop = function (stepper, seed) {\n  return (0, _loop.loop)(stepper, seed, this);\n};\n\n// -------------------------------------------------------\n\nexports.scan = _accumulate.scan;\nexports.reduce = _accumulate.reduce;\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @returns {Stream} new stream containing successive reduce results\n */\n\n_Stream2.default.prototype.scan = function (f, initial) {\n  return (0, _accumulate.scan)(f, initial, this);\n};\n\n/**\n * Reduce the stream to produce a single result.  Note that reducing an infinite\n * stream will return a Promise that never fulfills, but that may reject if an error\n * occurs.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial optional initial value\n * @returns {Promise} promise for the file result of the reduce\n */\n_Stream2.default.prototype.reduce = function (f, initial) {\n  return (0, _accumulate.reduce)(f, initial, this);\n};\n\n// -----------------------------------------------------------------------\n// Building and extending\n\nexports.concat = _build.concat;\nexports.startWith = _build.cons;\n\n/**\n * @param {Stream} tail\n * @returns {Stream} new stream containing all items in this followed by\n *  all items in tail\n */\n\n_Stream2.default.prototype.concat = function (tail) {\n  return (0, _build.concat)(this, tail);\n};\n\n/**\n * @param {*} x value to prepend\n * @returns {Stream} a new stream with x prepended\n */\n_Stream2.default.prototype.startWith = function (x) {\n  return (0, _build.cons)(x, this);\n};\n\n// -----------------------------------------------------------------------\n// Transforming\n\nexports.map = _transform.map;\nexports.constant = _transform.constant;\nexports.tap = _transform.tap;\nexports.ap = _applicative.ap;\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @returns {Stream} stream containing items transformed by f\n */\n\n_Stream2.default.prototype.map = function (f) {\n  return (0, _transform.map)(f, this);\n};\n\n/**\n * Assume this stream contains functions, and apply each function to each item\n * in the provided stream.  This generates, in effect, a cross product.\n * @param {Stream} xs stream of items to which\n * @returns {Stream} stream containing the cross product of items\n */\n_Stream2.default.prototype.ap = function (xs) {\n  return (0, _applicative.ap)(this, xs);\n};\n\n/**\n * Replace each value in the stream with x\n * @param {*} x\n * @returns {Stream} stream containing items replaced with x\n */\n_Stream2.default.prototype.constant = function (x) {\n  return (0, _transform.constant)(x, this);\n};\n\n/**\n * Perform a side effect for each item in the stream\n * @param {function(x:*):*} f side effect to execute for each item. The\n *  return value will be discarded.\n * @returns {Stream} new stream containing the same items as this stream\n */\n_Stream2.default.prototype.tap = function (f) {\n  return (0, _transform.tap)(f, this);\n};\n\n// -----------------------------------------------------------------------\n// Transducer support\n\nexports.transduce = _transduce.transduce;\n\n/**\n * Transform this stream by passing its events through a transducer.\n * @param  {function} transducer transducer function\n * @return {Stream} stream of events transformed by the transducer\n */\n\n_Stream2.default.prototype.transduce = function (transducer) {\n  return (0, _transduce.transduce)(transducer, this);\n};\n\n// -----------------------------------------------------------------------\n// FlatMapping\n\n// @deprecated flatMap, use chain instead\nexports.flatMap = _flatMap.flatMap;\nexports.chain = _flatMap.flatMap;\nexports.join = _flatMap.join;\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\n\n_Stream2.default.prototype.chain = function (f) {\n  return (0, _flatMap.flatMap)(f, this);\n};\n\n// @deprecated use chain instead\n_Stream2.default.prototype.flatMap = _Stream2.default.prototype.chain;\n\n/**\n* Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n* streams to the outer. Event arrival times are preserved.\n* @returns {Stream<X>} new stream containing all events of all inner streams\n*/\n_Stream2.default.prototype.join = function () {\n  return (0, _flatMap.join)(this);\n};\n\n// @deprecated flatMapEnd, use continueWith instead\nexports.continueWith = _continueWith.continueWith;\nexports.flatMapEnd = _continueWith.continueWith;\n\n/**\n * Map the end event to a new stream, and begin emitting its values.\n * @param {function(x:*):Stream} f function that receives the end event value,\n * and *must* return a new Stream to continue with.\n * @returns {Stream} new stream that emits all events from the original stream,\n * followed by all events from the stream returned by f.\n */\n\n_Stream2.default.prototype.continueWith = function (f) {\n  return (0, _continueWith.continueWith)(f, this);\n};\n\n// @deprecated use continueWith instead\n_Stream2.default.prototype.flatMapEnd = _Stream2.default.prototype.continueWith;\n\nexports.concatMap = _concatMap.concatMap;\n\n\n_Stream2.default.prototype.concatMap = function (f) {\n  return (0, _concatMap.concatMap)(f, this);\n};\n\n// -----------------------------------------------------------------------\n// Concurrent merging\n\nexports.mergeConcurrently = _mergeConcurrently.mergeConcurrently;\n\n/**\n * Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer, limiting the number of inner streams that may\n * be active concurrently.\n * @param {number} concurrency at most this many inner streams will be\n *  allowed to be active concurrently.\n * @return {Stream<X>} new stream containing all events of all inner\n *  streams, with limited concurrency.\n */\n\n_Stream2.default.prototype.mergeConcurrently = function (concurrency) {\n  return (0, _mergeConcurrently.mergeConcurrently)(concurrency, this);\n};\n\n// -----------------------------------------------------------------------\n// Merging\n\nexports.merge = _merge.merge;\nexports.mergeArray = _merge.mergeArray;\n\n/**\n * Merge this stream and all the provided streams\n * @returns {Stream} stream containing items from this stream and s in time\n * order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\n\n_Stream2.default.prototype.merge = function () /* ...streams*/{\n  return (0, _merge.mergeArray)(base.cons(this, arguments));\n};\n\n// -----------------------------------------------------------------------\n// Combining\n\nexports.combine = _combine.combine;\nexports.combineArray = _combine.combineArray;\n\n/**\n * Combine latest events from all input streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\n\n_Stream2.default.prototype.combine = function (f /*, ...streams*/) {\n  return (0, _combine.combineArray)(f, base.replace(this, 0, arguments));\n};\n\n// -----------------------------------------------------------------------\n// Sampling\n\nexports.sample = _sample.sample;\nexports.sampleArray = _sample.sampleArray;\nexports.sampleWith = _sample.sampleWith;\n\n/**\n * When an event arrives on sampler, emit the latest event value from stream.\n * @param {Stream} sampler stream of events at whose arrival time\n *  signal's latest value will be propagated\n * @returns {Stream} sampled stream of values\n */\n\n_Stream2.default.prototype.sampleWith = function (sampler) {\n  return (0, _sample.sampleWith)(sampler, this);\n};\n\n/**\n * When an event arrives on this stream, emit the result of calling f with the latest\n * values of all streams being sampled\n * @param {function(...values):*} f function to apply to each set of sampled values\n * @returns {Stream} stream of sampled and transformed values\n */\n_Stream2.default.prototype.sample = function (f /* ...streams */) {\n  return (0, _sample.sampleArray)(f, this, base.tail(arguments));\n};\n\n// -----------------------------------------------------------------------\n// Zipping\n\nexports.zip = _zip.zip;\nexports.zipArray = _zip.zipArray;\n\n/**\n * Pair-wise combine items with those in s. Given 2 streams:\n * [1,2,3] zipWith f [4,5,6] -> [f(1,4),f(2,5),f(3,6)]\n * Note: zip causes fast streams to buffer and wait for slow streams.\n * @param {function(a:Stream, b:Stream, ...):*} f function to combine items\n * @returns {Stream} new stream containing pairs\n */\n\n_Stream2.default.prototype.zip = function (f /*, ...streams*/) {\n  return (0, _zip.zipArray)(f, base.replace(this, 0, arguments));\n};\n\n// -----------------------------------------------------------------------\n// Switching\n\n// @deprecated switch, use switchLatest instead\nexports.switchLatest = _switch.switchLatest;\nexports.switch = _switch.switchLatest;\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @returns {Stream} switching stream\n */\n\n_Stream2.default.prototype.switchLatest = function () {\n  return (0, _switch.switchLatest)(this);\n};\n\n// @deprecated use switchLatest instead\n_Stream2.default.prototype.switch = _Stream2.default.prototype.switchLatest;\n\n// -----------------------------------------------------------------------\n// Filtering\n\n// @deprecated distinct, use skipRepeats instead\n// @deprecated distinctBy, use skipRepeatsWith instead\nexports.filter = _filter.filter;\nexports.skipRepeats = _filter.skipRepeats;\nexports.distinct = _filter.skipRepeats;\nexports.skipRepeatsWith = _filter.skipRepeatsWith;\nexports.distinctBy = _filter.skipRepeatsWith;\n\n/**\n * Retain only items matching a predicate\n * stream:                           -12345678-\n * filter(x => x % 2 === 0, stream): --2-4-6-8-\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\n\n_Stream2.default.prototype.filter = function (p) {\n  return (0, _filter.filter)(p, this);\n};\n\n/**\n * Skip repeated events, using === to compare items\n * stream:           -abbcd-\n * distinct(stream): -ab-cd-\n * @returns {Stream} stream with no repeated events\n */\n_Stream2.default.prototype.skipRepeats = function () {\n  return (0, _filter.skipRepeats)(this);\n};\n\n/**\n * Skip repeated events, using supplied equals function to compare items\n * @param {function(a:*, b:*):boolean} equals function to compare items\n * @returns {Stream} stream with no repeated events\n */\n_Stream2.default.prototype.skipRepeatsWith = function (equals) {\n  return (0, _filter.skipRepeatsWith)(equals, this);\n};\n\n// -----------------------------------------------------------------------\n// Slicing\n\nexports.take = _slice.take;\nexports.skip = _slice.skip;\nexports.slice = _slice.slice;\nexports.takeWhile = _slice.takeWhile;\nexports.skipWhile = _slice.skipWhile;\n\n/**\n * stream:          -abcd-\n * take(2, stream): -ab|\n * @param {Number} n take up to this many events\n * @returns {Stream} stream containing at most the first n items from this stream\n */\n\n_Stream2.default.prototype.take = function (n) {\n  return (0, _slice.take)(n, this);\n};\n\n/**\n * stream:          -abcd->\n * skip(2, stream): ---cd->\n * @param {Number} n skip this many events\n * @returns {Stream} stream not containing the first n events\n */\n_Stream2.default.prototype.skip = function (n) {\n  return (0, _slice.skip)(n, this);\n};\n\n/**\n * Slice a stream by event index. Equivalent to, but more efficient than\n * stream.take(end).skip(start);\n * NOTE: Negative start and end are not supported\n * @param {Number} start skip all events before the start index\n * @param {Number} end allow all events from the start index to the end index\n * @returns {Stream} stream containing items where start <= index < end\n */\n_Stream2.default.prototype.slice = function (start, end) {\n  return (0, _slice.slice)(start, end, this);\n};\n\n/**\n * stream:                        -123451234->\n * takeWhile(x => x < 5, stream): -1234|\n * @param {function(x:*):boolean} p predicate\n * @returns {Stream} stream containing items up to, but not including, the\n * first item for which p returns falsy.\n */\n_Stream2.default.prototype.takeWhile = function (p) {\n  return (0, _slice.takeWhile)(p, this);\n};\n\n/**\n * stream:                        -123451234->\n * skipWhile(x => x < 5, stream): -----51234->\n * @param {function(x:*):boolean} p predicate\n * @returns {Stream} stream containing items following *and including* the\n * first item for which p returns falsy.\n */\n_Stream2.default.prototype.skipWhile = function (p) {\n  return (0, _slice.skipWhile)(p, this);\n};\n\n// -----------------------------------------------------------------------\n// Time slicing\n\n// @deprecated takeUntil, use until instead\n// @deprecated skipUntil, use since instead\nexports.takeUntil = _timeslice.takeUntil;\nexports.until = _timeslice.takeUntil;\nexports.skipUntil = _timeslice.skipUntil;\nexports.since = _timeslice.skipUntil;\nexports.during = _timeslice.during;\n\n/**\n * stream:                    -a-b-c-d-e-f-g->\n * signal:                    -------x\n * takeUntil(signal, stream): -a-b-c-|\n * @param {Stream} signal retain only events in stream before the first\n * event in signal\n * @returns {Stream} new stream containing only events that occur before\n * the first event in signal.\n */\n\n_Stream2.default.prototype.until = function (signal) {\n  return (0, _timeslice.takeUntil)(signal, this);\n};\n\n// @deprecated use until instead\n_Stream2.default.prototype.takeUntil = _Stream2.default.prototype.until;\n\n/**\n* stream:                    -a-b-c-d-e-f-g->\n* signal:                    -------x\n* takeUntil(signal, stream): -------d-e-f-g->\n* @param {Stream} signal retain only events in stream at or after the first\n* event in signal\n* @returns {Stream} new stream containing only events that occur after\n* the first event in signal.\n*/\n_Stream2.default.prototype.since = function (signal) {\n  return (0, _timeslice.skipUntil)(signal, this);\n};\n\n// @deprecated use since instead\n_Stream2.default.prototype.skipUntil = _Stream2.default.prototype.since;\n\n/**\n* stream:                    -a-b-c-d-e-f-g->\n* timeWindow:                -----s\n* s:                               -----t\n* stream.during(timeWindow): -----c-d-e-|\n* @param {Stream<Stream>} timeWindow a stream whose first event (s) represents\n*  the window start time.  That event (s) is itself a stream whose first event (t)\n*  represents the window end time\n* @returns {Stream} new stream containing only events within the provided timespan\n*/\n_Stream2.default.prototype.during = function (timeWindow) {\n  return (0, _timeslice.during)(timeWindow, this);\n};\n\n// -----------------------------------------------------------------------\n// Delaying\n\nexports.delay = _delay.delay;\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\n\n_Stream2.default.prototype.delay = function (delayTime) {\n  return (0, _delay.delay)(delayTime, this);\n};\n\n// -----------------------------------------------------------------------\n// Getting event timestamp\n\nexports.timestamp = _timestamp.timestamp;\n\n/**\n * Expose event timestamps into the stream. Turns a Stream<X> into\n * Stream<{time:t, value:X}>\n * @returns {Stream<{time:number, value:*}>}\n */\n\n_Stream2.default.prototype.timestamp = function () {\n  return (0, _timestamp.timestamp)(this);\n};\n\n// -----------------------------------------------------------------------\n// Rate limiting\n\nexports.throttle = _limit.throttle;\nexports.debounce = _limit.debounce;\n\n/**\n * Limit the rate of events\n * stream:              abcd----abcd----\n * throttle(2, stream): a-c-----a-c-----\n * @param {Number} period time to suppress events\n * @returns {Stream} new stream that skips events for throttle period\n */\n\n_Stream2.default.prototype.throttle = function (period) {\n  return (0, _limit.throttle)(period, this);\n};\n\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * stream:              abcd----abcd----\n * debounce(2, stream): -----d-------d--\n * @param {Number} period events occuring more frequently than this\n *  on the provided scheduler will be suppressed\n * @returns {Stream} new debounced stream\n */\n_Stream2.default.prototype.debounce = function (period) {\n  return (0, _limit.debounce)(period, this);\n};\n\n// -----------------------------------------------------------------------\n// Awaiting Promises\n\n// @deprecated await, use awaitPromises instead\nexports.fromPromise = _promises.fromPromise;\nexports.awaitPromises = _promises.awaitPromises;\nexports.await = _promises.awaitPromises;\n\n/**\n * Await promises, turning a Stream<Promise<X>> into Stream<X>.  Preserves\n * event order, but timeshifts events based on promise resolution time.\n * @returns {Stream<X>} stream containing non-promise values\n */\n\n_Stream2.default.prototype.awaitPromises = function () {\n  return (0, _promises.awaitPromises)(this);\n};\n\n// @deprecated use awaitPromises instead\n_Stream2.default.prototype.await = _Stream2.default.prototype.awaitPromises;\n\n// -----------------------------------------------------------------------\n// Error handling\n\n// @deprecated flatMapError, use recoverWith instead\nexports.recoverWith = _errors.recoverWith;\nexports.flatMapError = _errors.flatMapError;\nexports.throwError = _errors.throwError;\n\n/**\n * If this stream encounters an error, recover and continue with items from stream\n * returned by f.\n * stream:                  -a-b-c-X-\n * f(X):                           d-e-f-g-\n * flatMapError(f, stream): -a-b-c-d-e-f-g-\n * @param {function(error:*):Stream} f function which returns a new stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\n\n_Stream2.default.prototype.recoverWith = function (f) {\n  return (0, _errors.flatMapError)(f, this);\n};\n\n// @deprecated use recoverWith instead\n_Stream2.default.prototype.flatMapError = _Stream2.default.prototype.recoverWith;\n\n// -----------------------------------------------------------------------\n// Multicasting\n\nexports.multicast = _multicast2.default;\n\n/**\n * Transform the stream into multicast stream.  That means that many subscribers\n * to the stream will not cause multiple invocations of the internal machinery.\n * @returns {Stream} new stream which will multicast events to all observers.\n */\n\n_Stream2.default.prototype.multicast = function () {\n  return (0, _multicast2.default)(this);\n};\n\n// export the instance of the defaultScheduler for third-party libraries\nexports.defaultScheduler = _defaultScheduler2.default;\n\n// export an implementation of Task used internally for third-party libraries\n\nexports.PropagateTask = _PropagateTask2.default;","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/fromEvent.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromEvent = fromEvent;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _EventTargetSource = require('./EventTargetSource');\n\nvar _EventTargetSource2 = _interopRequireDefault(_EventTargetSource);\n\nvar _EventEmitterSource = require('./EventEmitterSource');\n\nvar _EventEmitterSource2 = _interopRequireDefault(_EventEmitterSource);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a stream from an EventTarget, such as a DOM Node, or EventEmitter.\n * @param {String} event event type name, e.g. 'click'\n * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter\n * @param {*?} capture for DOM events, whether to use\n *  capturing--passed as 3rd parameter to addEventListener.\n * @returns {Stream} stream containing all events of the specified type\n * from the source.\n */\nfunction fromEvent(event, source, capture) {\n  // eslint-disable-line complexity\n  var s;\n\n  if (typeof source.addEventListener === 'function' && typeof source.removeEventListener === 'function') {\n    if (arguments.length < 3) {\n      capture = false;\n    }\n\n    s = new _EventTargetSource2.default(event, source, capture);\n  } else if (typeof source.addListener === 'function' && typeof source.removeListener === 'function') {\n    s = new _EventEmitterSource2.default(event, source);\n  } else {\n    throw new Error('source must support addEventListener/removeEventListener or addListener/removeListener');\n  }\n\n  return new _Stream2.default(s);\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/Stream.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Stream;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction Stream(source) {\n  this.source = source;\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/EventTargetSource.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = EventTargetSource;\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _tryEvent = require('./tryEvent');\n\nvar tryEvent = _interopRequireWildcard(_tryEvent);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction EventTargetSource(event, source, capture) {\n  this.event = event;\n  this.source = source;\n  this.capture = capture;\n}\n\nEventTargetSource.prototype.run = function (sink, scheduler) {\n  function addEvent(e) {\n    tryEvent.tryEvent(scheduler.now(), e, sink);\n  }\n\n  this.source.addEventListener(this.event, addEvent, this.capture);\n\n  return dispose.create(disposeEventTarget, { target: this, addEvent: addEvent });\n};\n\nfunction disposeEventTarget(info) {\n  var target = info.target;\n  target.source.removeEventListener(target.event, info.addEvent, target.capture);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/disposable/dispose.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tryDispose = tryDispose;\nexports.create = create;\nexports.empty = empty;\nexports.all = all;\nexports.promised = promised;\nexports.settable = settable;\nexports.once = once;\n\nvar _Disposable = require('./Disposable');\n\nvar _Disposable2 = _interopRequireDefault(_Disposable);\n\nvar _SettableDisposable = require('./SettableDisposable');\n\nvar _SettableDisposable2 = _interopRequireDefault(_SettableDisposable);\n\nvar _Promise = require('../Promise');\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\nvar map = base.map;\nvar identity = base.id;\n\n/**\n * Call disposable.dispose.  If it returns a promise, catch promise\n * error and forward it through the provided sink.\n * @param {number} t time\n * @param {{dispose: function}} disposable\n * @param {{error: function}} sink\n * @return {*} result of disposable.dispose\n */\nfunction tryDispose(t, disposable, sink) {\n  var result = disposeSafely(disposable);\n  return (0, _Promise.isPromise)(result) ? result.catch(function (e) {\n    sink.error(t, e);\n  }) : result;\n}\n\n/**\n * Create a new Disposable which will dispose its underlying resource\n * at most once.\n * @param {function} dispose function\n * @param {*?} data any data to be passed to disposer function\n * @return {Disposable}\n */\nfunction create(dispose, data) {\n  return once(new _Disposable2.default(dispose, data));\n}\n\n/**\n * Create a noop disposable. Can be used to satisfy a Disposable\n * requirement when no actual resource needs to be disposed.\n * @return {Disposable|exports|module.exports}\n */\nfunction empty() {\n  return new _Disposable2.default(identity, void 0);\n}\n\n/**\n * Create a disposable that will dispose all input disposables in parallel.\n * @param {Array<Disposable>} disposables\n * @return {Disposable}\n */\nfunction all(disposables) {\n  return create(disposeAll, disposables);\n}\n\nfunction disposeAll(disposables) {\n  return Promise.all(map(disposeSafely, disposables));\n}\n\nfunction disposeSafely(disposable) {\n  try {\n    return disposable.dispose();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Create a disposable from a promise for another disposable\n * @param {Promise<Disposable>} disposablePromise\n * @return {Disposable}\n */\nfunction promised(disposablePromise) {\n  return create(disposePromise, disposablePromise);\n}\n\nfunction disposePromise(disposablePromise) {\n  return disposablePromise.then(disposeOne);\n}\n\nfunction disposeOne(disposable) {\n  return disposable.dispose();\n}\n\n/**\n * Create a disposable proxy that allows its underlying disposable to\n * be set later.\n * @return {SettableDisposable}\n */\nfunction settable() {\n  return new _SettableDisposable2.default();\n}\n\n/**\n * Wrap an existing disposable (which may not already have been once()d)\n * so that it will only dispose its underlying resource at most once.\n * @param {{ dispose: function() }} disposable\n * @return {Disposable} wrapped disposable\n */\nfunction once(disposable) {\n  return new _Disposable2.default(disposeMemoized, memoized(disposable));\n}\n\nfunction disposeMemoized(memoized) {\n  if (!memoized.disposed) {\n    memoized.disposed = true;\n    memoized.value = disposeSafely(memoized.disposable);\n    memoized.disposable = void 0;\n  }\n\n  return memoized.value;\n}\n\nfunction memoized(disposable) {\n  return { disposed: false, disposable: disposable, value: void 0 };\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/disposable/Disposable.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Disposable;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Create a new Disposable which will dispose its underlying resource.\n * @param {function} dispose function\n * @param {*?} data any data to be passed to disposer function\n * @constructor\n */\nfunction Disposable(dispose, data) {\n  this._dispose = dispose;\n  this._data = data;\n}\n\nDisposable.prototype.dispose = function () {\n  return this._dispose(this._data);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/disposable/SettableDisposable.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = SettableDisposable;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction SettableDisposable() {\n  this.disposable = void 0;\n  this.disposed = false;\n  this._resolve = void 0;\n\n  var self = this;\n  this.result = new Promise(function (resolve) {\n    self._resolve = resolve;\n  });\n}\n\nSettableDisposable.prototype.setDisposable = function (disposable) {\n  if (this.disposable !== void 0) {\n    throw new Error('setDisposable called more than once');\n  }\n\n  this.disposable = disposable;\n\n  if (this.disposed) {\n    this._resolve(disposable.dispose());\n  }\n};\n\nSettableDisposable.prototype.dispose = function () {\n  if (this.disposed) {\n    return this.result;\n  }\n\n  this.disposed = true;\n\n  if (this.disposable !== void 0) {\n    this.result = this.disposable.dispose();\n  }\n\n  return this.result;\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/Promise.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPromise = isPromise;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction isPromise(p) {\n  return p !== null && typeof p === 'object' && typeof p.then === 'function';\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/tryEvent.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tryEvent = tryEvent;\nexports.tryEnd = tryEnd;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction tryEvent(t, x, sink) {\n  try {\n    sink.event(t, x);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}\n\nfunction tryEnd(t, x, sink) {\n  try {\n    sink.end(t, x);\n  } catch (e) {\n    sink.error(t, e);\n  }\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/EventEmitterSource.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = EventEmitterSource;\n\nvar _DeferredSink = require('../sink/DeferredSink');\n\nvar _DeferredSink2 = _interopRequireDefault(_DeferredSink);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _tryEvent = require('./tryEvent');\n\nvar tryEvent = _interopRequireWildcard(_tryEvent);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction EventEmitterSource(event, source) {\n  this.event = event;\n  this.source = source;\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nEventEmitterSource.prototype.run = function (sink, scheduler) {\n  // NOTE: Because EventEmitter allows events in the same call stack as\n  // a listener is added, use a DeferredSink to buffer events\n  // until the stack clears, then propagate.  This maintains most.js's\n  // invariant that no event will be delivered in the same call stack\n  // as an observer begins observing.\n  var dsink = new _DeferredSink2.default(sink);\n\n  function addEventVariadic(a) {\n    var arguments$1 = arguments;\n\n    var l = arguments.length;\n    if (l > 1) {\n      var arr = new Array(l);\n      for (var i = 0; i < l; ++i) {\n        arr[i] = arguments$1[i];\n      }\n      tryEvent.tryEvent(scheduler.now(), arr, dsink);\n    } else {\n      tryEvent.tryEvent(scheduler.now(), a, dsink);\n    }\n  }\n\n  this.source.addListener(this.event, addEventVariadic);\n\n  return dispose.create(disposeEventEmitter, { target: this, addEvent: addEventVariadic });\n};\n\nfunction disposeEventEmitter(info) {\n  var target = info.target;\n  target.source.removeListener(target.event, info.addEvent);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/sink/DeferredSink.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = DeferredSink;\n\nvar _task = require('../task');\n\nfunction DeferredSink(sink) {\n  this.sink = sink;\n  this.events = [];\n  this.active = true;\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nDeferredSink.prototype.event = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n\n  if (this.events.length === 0) {\n    (0, _task.defer)(new PropagateAllTask(this.sink, t, this.events));\n  }\n\n  this.events.push({ time: t, value: x });\n};\n\nDeferredSink.prototype.end = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n\n  this._end(new EndTask(t, x, this.sink));\n};\n\nDeferredSink.prototype.error = function (t, e) {\n  this._end(new ErrorTask(t, e, this.sink));\n};\n\nDeferredSink.prototype._end = function (task) {\n  this.active = false;\n  (0, _task.defer)(task);\n};\n\nfunction PropagateAllTask(sink, time, events) {\n  this.sink = sink;\n  this.events = events;\n  this.time = time;\n}\n\nPropagateAllTask.prototype.run = function () {\n  var this$1 = this;\n\n  var events = this.events;\n  var sink = this.sink;\n  var event;\n\n  for (var i = 0, l = events.length; i < l; ++i) {\n    event = events[i];\n    this$1.time = event.time;\n    sink.event(event.time, event.value);\n  }\n\n  events.length = 0;\n};\n\nPropagateAllTask.prototype.error = function (e) {\n  this.sink.error(this.time, e);\n};\n\nfunction EndTask(t, x, sink) {\n  this.time = t;\n  this.value = x;\n  this.sink = sink;\n}\n\nEndTask.prototype.run = function () {\n  this.sink.end(this.time, this.value);\n};\n\nEndTask.prototype.error = function (e) {\n  this.sink.error(this.time, e);\n};\n\nfunction ErrorTask(t, e, sink) {\n  this.time = t;\n  this.value = e;\n  this.sink = sink;\n}\n\nErrorTask.prototype.run = function () {\n  this.sink.error(this.time, this.value);\n};\n\nErrorTask.prototype.error = function (e) {\n  throw e;\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/task.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defer = defer;\nexports.runTask = runTask;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction defer(task) {\n  return Promise.resolve(task).then(runTask);\n}\n\nfunction runTask(task) {\n  try {\n    return task.run();\n  } catch (e) {\n    return task.error(e);\n  }\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/unfold.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unfold = unfold;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Compute a stream by unfolding tuples of future values from a seed value\n * Event times may be controlled by returning a Promise from f\n * @param {function(seed:*):{value:*, seed:*, done:boolean}|Promise<{value:*, seed:*, done:boolean}>} f unfolding function accepts\n *  a seed and returns a new tuple with a value, new seed, and boolean done flag.\n *  If tuple.done is true, the stream will end.\n * @param {*} seed seed value\n * @returns {Stream} stream containing all value of all tuples produced by the\n *  unfolding function.\n */\nfunction unfold(f, seed) {\n  return new _Stream2.default(new UnfoldSource(f, seed));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction UnfoldSource(f, seed) {\n  this.f = f;\n  this.value = seed;\n}\n\nUnfoldSource.prototype.run = function (sink, scheduler) {\n  return new Unfold(this.f, this.value, sink, scheduler);\n};\n\nfunction Unfold(f, x, sink, scheduler) {\n  this.f = f;\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.active = true;\n\n  var self = this;\n  function err(e) {\n    self.sink.error(self.scheduler.now(), e);\n  }\n\n  function start(unfold) {\n    return stepUnfold(unfold, x);\n  }\n\n  Promise.resolve(this).then(start).catch(err);\n}\n\nUnfold.prototype.dispose = function () {\n  this.active = false;\n};\n\nfunction stepUnfold(unfold, x) {\n  var f = unfold.f;\n  return Promise.resolve(f(x)).then(function (tuple) {\n    return continueUnfold(unfold, tuple);\n  });\n}\n\nfunction continueUnfold(unfold, tuple) {\n  if (tuple.done) {\n    unfold.sink.end(unfold.scheduler.now(), tuple.value);\n    return tuple.value;\n  }\n\n  unfold.sink.event(unfold.scheduler.now(), tuple.value);\n\n  if (!unfold.active) {\n    return tuple.value;\n  }\n  return stepUnfold(unfold, tuple.seed);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/iterate.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.iterate = iterate;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Compute a stream by iteratively calling f to produce values\n * Event times may be controlled by returning a Promise from f\n * @param {function(x:*):*|Promise<*>} f\n * @param {*} x initial value\n * @returns {Stream}\n */\nfunction iterate(f, x) {\n  return new _Stream2.default(new IterateSource(f, x));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction IterateSource(f, x) {\n  this.f = f;\n  this.value = x;\n}\n\nIterateSource.prototype.run = function (sink, scheduler) {\n  return new Iterate(this.f, this.value, sink, scheduler);\n};\n\nfunction Iterate(f, initial, sink, scheduler) {\n  this.f = f;\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.active = true;\n\n  var x = initial;\n\n  var self = this;\n  function err(e) {\n    self.sink.error(self.scheduler.now(), e);\n  }\n\n  function start(iterate) {\n    return stepIterate(iterate, x);\n  }\n\n  Promise.resolve(this).then(start).catch(err);\n}\n\nIterate.prototype.dispose = function () {\n  this.active = false;\n};\n\nfunction stepIterate(iterate, x) {\n  iterate.sink.event(iterate.scheduler.now(), x);\n\n  if (!iterate.active) {\n    return x;\n  }\n\n  var f = iterate.f;\n  return Promise.resolve(f(x)).then(function (y) {\n    return continueIterate(iterate, y);\n  });\n}\n\nfunction continueIterate(iterate, x) {\n  return !iterate.active ? iterate.value : stepIterate(iterate, x);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/generate.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generate = generate;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Compute a stream using an *async* generator, which yields promises\n * to control event times.\n * @param f\n * @returns {Stream}\n */\n/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction generate(f /*, ...args */) {\n  return new _Stream2.default(new GenerateSource(f, base.tail(arguments)));\n}\n\nfunction GenerateSource(f, args) {\n  this.f = f;\n  this.args = args;\n}\n\nGenerateSource.prototype.run = function (sink, scheduler) {\n  return new Generate(this.f.apply(void 0, this.args), sink, scheduler);\n};\n\nfunction Generate(iterator, sink, scheduler) {\n  this.iterator = iterator;\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.active = true;\n\n  var self = this;\n  function err(e) {\n    self.sink.error(self.scheduler.now(), e);\n  }\n\n  Promise.resolve(this).then(next).catch(err);\n}\n\nfunction next(generate, x) {\n  return generate.active ? handle(generate, generate.iterator.next(x)) : x;\n}\n\nfunction handle(generate, result) {\n  if (result.done) {\n    return generate.sink.end(generate.scheduler.now(), result.value);\n  }\n\n  return Promise.resolve(result.value).then(function (x) {\n    return emit(generate, x);\n  }, function (e) {\n    return error(generate, e);\n  });\n}\n\nfunction emit(generate, x) {\n  generate.sink.event(generate.scheduler.now(), x);\n  return next(generate, x);\n}\n\nfunction error(generate, e) {\n  return handle(generate, generate.iterator.throw(e));\n}\n\nGenerate.prototype.dispose = function () {\n  this.active = false;\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/core.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.of = of;\nexports.empty = empty;\nexports.never = never;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Stream containing only x\n * @param {*} x\n * @returns {Stream}\n */\nfunction of(x) {\n  return new _Stream2.default(new Just(x));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction Just(x) {\n  this.value = x;\n}\n\nJust.prototype.run = function (sink, scheduler) {\n  return scheduler.asap(new _PropagateTask2.default(runJust, this.value, sink));\n};\n\nfunction runJust(t, x, sink) {\n  sink.event(t, x);\n  sink.end(t, void 0);\n}\n\n/**\n * Stream containing no events and ends immediately\n * @returns {Stream}\n */\nfunction empty() {\n  return EMPTY;\n}\n\nfunction EmptySource() {}\n\nEmptySource.prototype.run = function (sink, scheduler) {\n  var task = _PropagateTask2.default.end(void 0, sink);\n  scheduler.asap(task);\n\n  return dispose.create(disposeEmpty, task);\n};\n\nfunction disposeEmpty(task) {\n  return task.dispose();\n}\n\nvar EMPTY = new _Stream2.default(new EmptySource());\n\n/**\n * Stream containing no events and never ends\n * @returns {Stream}\n */\nfunction never() {\n  return NEVER;\n}\n\nfunction NeverSource() {}\n\nNeverSource.prototype.run = function () {\n  return dispose.empty();\n};\n\nvar NEVER = new _Stream2.default(new NeverSource());","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/scheduler/PropagateTask.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = PropagateTask;\n\nvar _fatalError = require('../fatalError');\n\nvar _fatalError2 = _interopRequireDefault(_fatalError);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction PropagateTask(run, value, sink) {\n  this._run = run;\n  this.value = value;\n  this.sink = sink;\n  this.active = true;\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nPropagateTask.event = function (value, sink) {\n  return new PropagateTask(emit, value, sink);\n};\n\nPropagateTask.end = function (value, sink) {\n  return new PropagateTask(end, value, sink);\n};\n\nPropagateTask.error = function (value, sink) {\n  return new PropagateTask(error, value, sink);\n};\n\nPropagateTask.prototype.dispose = function () {\n  this.active = false;\n};\n\nPropagateTask.prototype.run = function (t) {\n  if (!this.active) {\n    return;\n  }\n  this._run(t, this.value, this.sink);\n};\n\nPropagateTask.prototype.error = function (t, e) {\n  if (!this.active) {\n    return (0, _fatalError2.default)(e);\n  }\n  this.sink.error(t, e);\n};\n\nfunction error(t, e, sink) {\n  sink.error(t, e);\n}\n\nfunction emit(t, x, sink) {\n  sink.event(t, x);\n}\n\nfunction end(t, x, sink) {\n  sink.end(t, x);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/fatalError.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = fatalError;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction fatalError(e) {\n  setTimeout(function () {\n    throw e;\n  }, 0);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/from.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.from = from;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _fromArray = require('./fromArray');\n\nvar _iterable = require('../iterable');\n\nvar _fromIterable = require('./fromIterable');\n\nvar _getObservable = require('../observable/getObservable');\n\nvar _getObservable2 = _interopRequireDefault(_getObservable);\n\nvar _fromObservable = require('../observable/fromObservable');\n\nvar _prelude = require('@most/prelude');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction from(a) {\n  // eslint-disable-line complexity\n  if (a instanceof _Stream2.default) {\n    return a;\n  }\n\n  var observable = (0, _getObservable2.default)(a);\n  if (observable != null) {\n    return (0, _fromObservable.fromObservable)(observable);\n  }\n\n  if (Array.isArray(a) || (0, _prelude.isArrayLike)(a)) {\n    return (0, _fromArray.fromArray)(a);\n  }\n\n  if ((0, _iterable.isIterable)(a)) {\n    return (0, _fromIterable.fromIterable)(a);\n  }\n\n  throw new TypeError('from(x) must be observable, iterable, or array-like: ' + a);\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/fromArray.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromArray = fromArray;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction fromArray(a) {\n  return new _Stream2.default(new ArraySource(a));\n}\n\nfunction ArraySource(a) {\n  this.array = a;\n}\n\nArraySource.prototype.run = function (sink, scheduler) {\n  return scheduler.asap(new _PropagateTask2.default(runProducer, this.array, sink));\n};\n\nfunction runProducer(t, array, sink) {\n  for (var i = 0, l = array.length; i < l && this.active; ++i) {\n    sink.event(t, array[i]);\n  }\n\n  this.active && end(t);\n\n  function end(t) {\n    sink.end(t);\n  }\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/iterable.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIterable = isIterable;\nexports.getIterator = getIterator;\nexports.makeIterable = makeIterable;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/*global Set, Symbol*/\nvar iteratorSymbol;\n// Firefox ships a partial implementation using the name @@iterator.\n// https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14\nif (typeof Set === 'function' && typeof new Set()['@@iterator'] === 'function') {\n  iteratorSymbol = '@@iterator';\n} else {\n  iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator || '_es6shim_iterator_';\n}\n\nfunction isIterable(o) {\n  return typeof o[iteratorSymbol] === 'function';\n}\n\nfunction getIterator(o) {\n  return o[iteratorSymbol]();\n}\n\nfunction makeIterable(f, o) {\n  o[iteratorSymbol] = f;\n  return o;\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/fromIterable.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromIterable = fromIterable;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _iterable = require('../iterable');\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction fromIterable(iterable) {\n  return new _Stream2.default(new IterableSource(iterable));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction IterableSource(iterable) {\n  this.iterable = iterable;\n}\n\nIterableSource.prototype.run = function (sink, scheduler) {\n  return scheduler.asap(new _PropagateTask2.default(runProducer, (0, _iterable.getIterator)(this.iterable), sink));\n};\n\nfunction runProducer(t, iterator, sink) {\n  var r = iterator.next();\n\n  while (!r.done && this.active) {\n    sink.event(t, r.value);\n    r = iterator.next();\n  }\n\n  sink.end(t, r.value);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/observable/getObservable.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getObservable;\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getObservable(o) {\n  // eslint-disable-line complexity\n  var obs = null;\n  if (o) {\n    // Access foreign method only once\n    var method = o[_symbolObservable2.default];\n    if (typeof method === 'function') {\n      obs = method.call(o);\n      if (!(obs && typeof obs.subscribe === 'function')) {\n        throw new TypeError('invalid observable ' + obs);\n      }\n    }\n  }\n\n  return obs;\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/observable/fromObservable.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromObservable = fromObservable;\nexports.ObservableSource = ObservableSource;\nexports.SubscriberSink = SubscriberSink;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _tryEvent = require('../source/tryEvent');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction fromObservable(observable) {\n  return new _Stream2.default(new ObservableSource(observable));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction ObservableSource(observable) {\n  this.observable = observable;\n}\n\nObservableSource.prototype.run = function (sink, scheduler) {\n  var sub = this.observable.subscribe(new SubscriberSink(sink, scheduler));\n  if (typeof sub === 'function') {\n    return dispose.create(sub);\n  } else if (sub && typeof sub.unsubscribe === 'function') {\n    return dispose.create(unsubscribe, sub);\n  }\n\n  throw new TypeError('Observable returned invalid subscription ' + String(sub));\n};\n\nfunction SubscriberSink(sink, scheduler) {\n  this.sink = sink;\n  this.scheduler = scheduler;\n}\n\nSubscriberSink.prototype.next = function (x) {\n  (0, _tryEvent.tryEvent)(this.scheduler.now(), x, this.sink);\n};\n\nSubscriberSink.prototype.complete = function (x) {\n  (0, _tryEvent.tryEnd)(this.scheduler.now(), x, this.sink);\n};\n\nSubscriberSink.prototype.error = function (e) {\n  this.sink.error(this.scheduler.now(), e);\n};\n\nfunction unsubscribe(subscription) {\n  return subscription.unsubscribe();\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/source/periodic.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.periodic = periodic;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a stream that emits the current time periodically\n * @param {Number} period periodicity of events in millis\n * @param {*} deprecatedValue @deprecated value to emit each period\n * @returns {Stream} new stream that emits the current time every period\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction periodic(period, deprecatedValue) {\n  return new _Stream2.default(new Periodic(period, deprecatedValue));\n}\n\nfunction Periodic(period, value) {\n  this.period = period;\n  this.value = value;\n}\n\nPeriodic.prototype.run = function (sink, scheduler) {\n  return scheduler.periodic(this.period, _PropagateTask2.default.event(this.value, sink));\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/observable/subscribe.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribe = subscribe;\nexports.SubscribeObserver = SubscribeObserver;\nexports.Subscription = Subscription;\n\nvar _defaultScheduler = require('../scheduler/defaultScheduler');\n\nvar _defaultScheduler2 = _interopRequireDefault(_defaultScheduler);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _fatalError = require('../fatalError');\n\nvar _fatalError2 = _interopRequireDefault(_fatalError);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction subscribe(subscriber, stream) {\n  if (subscriber == null || typeof subscriber !== 'object') {\n    throw new TypeError('subscriber must be an object');\n  }\n\n  var disposable = dispose.settable();\n  var observer = new SubscribeObserver(_fatalError2.default, subscriber, disposable);\n\n  disposable.setDisposable(stream.source.run(observer, _defaultScheduler2.default));\n\n  return new Subscription(disposable);\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction SubscribeObserver(fatalError, subscriber, disposable) {\n  this.fatalError = fatalError;\n  this.subscriber = subscriber;\n  this.disposable = disposable;\n}\n\nSubscribeObserver.prototype.event = function (t, x) {\n  if (!this.disposable.disposed && typeof this.subscriber.next === 'function') {\n    this.subscriber.next(x);\n  }\n};\n\nSubscribeObserver.prototype.end = function (t, x) {\n  if (!this.disposable.disposed) {\n    var s = this.subscriber;\n    doDispose(this.fatalError, s, s.complete, s.error, this.disposable, x);\n  }\n};\n\nSubscribeObserver.prototype.error = function (t, e) {\n  var s = this.subscriber;\n  doDispose(this.fatalError, s, s.error, s.error, this.disposable, e);\n};\n\nfunction Subscription(disposable) {\n  this.disposable = disposable;\n}\n\nSubscription.prototype.unsubscribe = function () {\n  this.disposable.dispose();\n};\n\nfunction doDispose(fatal, subscriber, complete, error, disposable, x) {\n  Promise.resolve(disposable.dispose()).then(function () {\n    if (typeof complete === 'function') {\n      complete.call(subscriber, x);\n    }\n  }).catch(function (e) {\n    if (typeof error === 'function') {\n      error.call(subscriber, e);\n    }\n  }).catch(fatal);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/scheduler/defaultScheduler.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Scheduler = require('./Scheduler');\n\nvar _Scheduler2 = _interopRequireDefault(_Scheduler);\n\nvar _ClockTimer = require('./ClockTimer');\n\nvar _ClockTimer2 = _interopRequireDefault(_ClockTimer);\n\nvar _Timeline = require('./Timeline');\n\nvar _Timeline2 = _interopRequireDefault(_Timeline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar defaultScheduler = new _Scheduler2.default(new _ClockTimer2.default(), new _Timeline2.default()); /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexports.default = defaultScheduler;","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/scheduler/Scheduler.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Scheduler;\n\nvar _ScheduledTask = require('./ScheduledTask');\n\nvar _ScheduledTask2 = _interopRequireDefault(_ScheduledTask);\n\nvar _task = require('../task');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction Scheduler(timer, timeline) {\n  this.timer = timer;\n  this.timeline = timeline;\n\n  this._timer = null;\n  this._nextArrival = Infinity;\n\n  var self = this;\n  this._runReadyTasksBound = function () {\n    self._runReadyTasks(self.now());\n  };\n}\n\nScheduler.prototype.now = function () {\n  return this.timer.now();\n};\n\nScheduler.prototype.asap = function (task) {\n  return this.schedule(0, -1, task);\n};\n\nScheduler.prototype.delay = function (delay, task) {\n  return this.schedule(delay, -1, task);\n};\n\nScheduler.prototype.periodic = function (period, task) {\n  return this.schedule(0, period, task);\n};\n\nScheduler.prototype.schedule = function (delay, period, task) {\n  var now = this.now();\n  var st = new _ScheduledTask2.default(now + Math.max(0, delay), period, task, this);\n\n  this.timeline.add(st);\n  this._scheduleNextRun(now);\n  return st;\n};\n\nScheduler.prototype.cancel = function (task) {\n  task.active = false;\n  if (this.timeline.remove(task)) {\n    this._reschedule();\n  }\n};\n\nScheduler.prototype.cancelAll = function (f) {\n  this.timeline.removeAll(f);\n  this._reschedule();\n};\n\nScheduler.prototype._reschedule = function () {\n  if (this.timeline.isEmpty()) {\n    this._unschedule();\n  } else {\n    this._scheduleNextRun(this.now());\n  }\n};\n\nScheduler.prototype._unschedule = function () {\n  this.timer.clearTimer(this._timer);\n  this._timer = null;\n};\n\nScheduler.prototype._scheduleNextRun = function (now) {\n  // eslint-disable-line complexity\n  if (this.timeline.isEmpty()) {\n    return;\n  }\n\n  var nextArrival = this.timeline.nextArrival();\n\n  if (this._timer === null) {\n    this._scheduleNextArrival(nextArrival, now);\n  } else if (nextArrival < this._nextArrival) {\n    this._unschedule();\n    this._scheduleNextArrival(nextArrival, now);\n  }\n};\n\nScheduler.prototype._scheduleNextArrival = function (nextArrival, now) {\n  this._nextArrival = nextArrival;\n  var delay = Math.max(0, nextArrival - now);\n  this._timer = this.timer.setTimer(this._runReadyTasksBound, delay);\n};\n\nScheduler.prototype._runReadyTasks = function (now) {\n  this._timer = null;\n  this.timeline.runTasks(now, _task.runTask);\n  this._scheduleNextRun(this.now());\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/scheduler/ScheduledTask.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ScheduledTask;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction ScheduledTask(delay, period, task, scheduler) {\n  this.time = delay;\n  this.period = period;\n  this.task = task;\n  this.scheduler = scheduler;\n  this.active = true;\n}\n\nScheduledTask.prototype.run = function () {\n  return this.task.run(this.time);\n};\n\nScheduledTask.prototype.error = function (e) {\n  return this.task.error(this.time, e);\n};\n\nScheduledTask.prototype.dispose = function () {\n  this.scheduler.cancel(this);\n  return this.task.dispose();\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/scheduler/ClockTimer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ClockTimer;\n\nvar _task = require('../task');\n\n/*global setTimeout, clearTimeout*/\n\nfunction ClockTimer() {} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nClockTimer.prototype.now = Date.now;\n\nClockTimer.prototype.setTimer = function (f, dt) {\n  return dt <= 0 ? runAsap(f) : setTimeout(f, dt);\n};\n\nClockTimer.prototype.clearTimer = function (t) {\n  return t instanceof Asap ? t.cancel() : clearTimeout(t);\n};\n\nfunction Asap(f) {\n  this.f = f;\n  this.active = true;\n}\n\nAsap.prototype.run = function () {\n  return this.active && this.f();\n};\n\nAsap.prototype.error = function (e) {\n  throw e;\n};\n\nAsap.prototype.cancel = function () {\n  this.active = false;\n};\n\nfunction runAsap(f) {\n  var task = new Asap(f);\n  (0, _task.defer)(task);\n  return task;\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/scheduler/Timeline.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Timeline;\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction Timeline() {\n  this.tasks = [];\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nTimeline.prototype.nextArrival = function () {\n  return this.isEmpty() ? Infinity : this.tasks[0].time;\n};\n\nTimeline.prototype.isEmpty = function () {\n  return this.tasks.length === 0;\n};\n\nTimeline.prototype.add = function (st) {\n  insertByTime(st, this.tasks);\n};\n\nTimeline.prototype.remove = function (st) {\n  var i = binarySearch(st.time, this.tasks);\n\n  if (i >= 0 && i < this.tasks.length) {\n    var at = base.findIndex(st, this.tasks[i].events);\n    if (at >= 0) {\n      this.tasks[i].events.splice(at, 1);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nTimeline.prototype.removeAll = function (f) {\n  var this$1 = this;\n\n  for (var i = 0, l = this.tasks.length; i < l; ++i) {\n    removeAllFrom(f, this$1.tasks[i]);\n  }\n};\n\nTimeline.prototype.runTasks = function (t, runTask) {\n  var this$1 = this;\n\n  var tasks = this.tasks;\n  var l = tasks.length;\n  var i = 0;\n\n  while (i < l && tasks[i].time <= t) {\n    ++i;\n  }\n\n  this.tasks = tasks.slice(i);\n\n  // Run all ready tasks\n  for (var j = 0; j < i; ++j) {\n    this$1.tasks = runTasks(runTask, tasks[j], this$1.tasks);\n  }\n};\n\nfunction runTasks(runTask, timeslot, tasks) {\n  // eslint-disable-line complexity\n  var events = timeslot.events;\n  for (var i = 0; i < events.length; ++i) {\n    var task = events[i];\n\n    if (task.active) {\n      runTask(task);\n\n      // Reschedule periodic repeating tasks\n      // Check active again, since a task may have canceled itself\n      if (task.period >= 0 && task.active) {\n        task.time = task.time + task.period;\n        insertByTime(task, tasks);\n      }\n    }\n  }\n\n  return tasks;\n}\n\nfunction insertByTime(task, timeslots) {\n  // eslint-disable-line complexity\n  var l = timeslots.length;\n\n  if (l === 0) {\n    timeslots.push(newTimeslot(task.time, [task]));\n    return;\n  }\n\n  var i = binarySearch(task.time, timeslots);\n\n  if (i >= l) {\n    timeslots.push(newTimeslot(task.time, [task]));\n  } else if (task.time === timeslots[i].time) {\n    timeslots[i].events.push(task);\n  } else {\n    timeslots.splice(i, 0, newTimeslot(task.time, [task]));\n  }\n}\n\nfunction removeAllFrom(f, timeslot) {\n  timeslot.events = base.removeAll(f, timeslot.events);\n}\n\nfunction binarySearch(t, sortedArray) {\n  // eslint-disable-line complexity\n  var lo = 0;\n  var hi = sortedArray.length;\n  var mid, y;\n\n  while (lo < hi) {\n    mid = Math.floor((lo + hi) / 2);\n    y = sortedArray[mid];\n\n    if (t === y.time) {\n      return mid;\n    } else if (t < y.time) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return hi;\n}\n\nfunction newTimeslot(t, events) {\n  return { time: t, events: events };\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/thru.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.thru = thru;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction thru(f, stream) {\n  return f(stream);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/observe.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observe = observe;\nexports.drain = drain;\n\nvar _runSource = require('../runSource');\n\nvar _transform = require('./transform');\n\n/**\n * Observe all the event values in the stream in time order. The\n * provided function `f` will be called for each event value\n * @param {function(x:T):*} f function to call with each event value\n * @param {Stream<T>} stream stream to observe\n * @return {Promise} promise that fulfills after the stream ends without\n *  an error, or rejects if the stream ends with an error.\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction observe(f, stream) {\n  return drain((0, _transform.tap)(f, stream));\n}\n\n/**\n * \"Run\" a stream by creating demand and consuming all events\n * @param {Stream<T>} stream stream to drain\n * @return {Promise} promise that fulfills after the stream ends without\n *  an error, or rejects if the stream ends with an error.\n */\nfunction drain(stream) {\n  return (0, _runSource.withDefaultScheduler)(stream.source);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/runSource.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withDefaultScheduler = withDefaultScheduler;\nexports.withScheduler = withScheduler;\n\nvar _dispose = require('./disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _defaultScheduler = require('./scheduler/defaultScheduler');\n\nvar _defaultScheduler2 = _interopRequireDefault(_defaultScheduler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction withDefaultScheduler(source) {\n  return withScheduler(source, _defaultScheduler2.default);\n}\n\nfunction withScheduler(source, scheduler) {\n  return new Promise(function (resolve, reject) {\n    runSource(source, scheduler, resolve, reject);\n  });\n}\n\nfunction runSource(source, scheduler, resolve, reject) {\n  var disposable = dispose.settable();\n  var observer = new Drain(resolve, reject, disposable);\n\n  disposable.setDisposable(source.run(observer, scheduler));\n}\n\nfunction Drain(end, error, disposable) {\n  this._end = end;\n  this._error = error;\n  this._disposable = disposable;\n  this.active = true;\n}\n\nDrain.prototype.event = function (t, x) {};\n\nDrain.prototype.end = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n  this.active = false;\n  disposeThen(this._end, this._error, this._disposable, x);\n};\n\nDrain.prototype.error = function (t, e) {\n  this.active = false;\n  disposeThen(this._error, this._error, this._disposable, e);\n};\n\nfunction disposeThen(end, error, disposable, x) {\n  Promise.resolve(disposable.dispose()).then(function () {\n    end(x);\n  }, error);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/transform.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.map = map;\nexports.constant = constant;\nexports.tap = tap;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Map = require('../fusion/Map');\n\nvar _Map2 = _interopRequireDefault(_Map);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @param {Stream} stream stream to map\n * @returns {Stream} stream containing items transformed by f\n */\nfunction map(f, stream) {\n  return new _Stream2.default(_Map2.default.create(f, stream.source));\n}\n\n/**\n* Replace each value in the stream with x\n* @param {*} x\n* @param {Stream} stream\n* @returns {Stream} stream containing items replaced with x\n*/\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction constant(x, stream) {\n  return map(function () {\n    return x;\n  }, stream);\n}\n\n/**\n* Perform a side effect for each item in the stream\n* @param {function(x:*):*} f side effect to execute for each item. The\n*  return value will be discarded.\n* @param {Stream} stream stream to tap\n* @returns {Stream} new stream containing the same items as this stream\n*/\nfunction tap(f, stream) {\n  return new _Stream2.default(new Tap(f, stream.source));\n}\n\nfunction Tap(f, source) {\n  this.source = source;\n  this.f = f;\n}\n\nTap.prototype.run = function (sink, scheduler) {\n  return this.source.run(new TapSink(this.f, sink), scheduler);\n};\n\nfunction TapSink(f, sink) {\n  this.sink = sink;\n  this.f = f;\n}\n\nTapSink.prototype.end = _Pipe2.default.prototype.end;\nTapSink.prototype.error = _Pipe2.default.prototype.error;\n\nTapSink.prototype.event = function (t, x) {\n  var f = this.f;\n  f(x);\n  this.sink.event(t, x);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/fusion/Map.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Map;\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _Filter = require('./Filter');\n\nvar _Filter2 = _interopRequireDefault(_Filter);\n\nvar _FilterMap = require('./FilterMap');\n\nvar _FilterMap2 = _interopRequireDefault(_FilterMap);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction Map(f, source) {\n  this.f = f;\n  this.source = source;\n}\n\n/**\n * Create a mapped source, fusing adjacent map.map, filter.map,\n * and filter.map.map if possible\n * @param {function(*):*} f mapping function\n * @param {{run:function}} source source to map\n * @returns {Map|FilterMap} mapped source, possibly fused\n */\nMap.create = function createMap(f, source) {\n  if (source instanceof Map) {\n    return new Map(base.compose(f, source.f), source.source);\n  }\n\n  if (source instanceof _Filter2.default) {\n    return new _FilterMap2.default(source.p, f, source.source);\n  }\n\n  return new Map(f, source);\n};\n\nMap.prototype.run = function (sink, scheduler) {\n  // eslint-disable-line no-extend-native\n  return this.source.run(new MapSink(this.f, sink), scheduler);\n};\n\nfunction MapSink(f, sink) {\n  this.f = f;\n  this.sink = sink;\n}\n\nMapSink.prototype.end = _Pipe2.default.prototype.end;\nMapSink.prototype.error = _Pipe2.default.prototype.error;\n\nMapSink.prototype.event = function (t, x) {\n  var f = this.f;\n  this.sink.event(t, f(x));\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/sink/Pipe.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Pipe;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * A sink mixin that simply forwards event, end, and error to\n * another sink.\n * @param sink\n * @constructor\n */\nfunction Pipe(sink) {\n  this.sink = sink;\n}\n\nPipe.prototype.event = function (t, x) {\n  return this.sink.event(t, x);\n};\n\nPipe.prototype.end = function (t, x) {\n  return this.sink.end(t, x);\n};\n\nPipe.prototype.error = function (t, e) {\n  return this.sink.error(t, e);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/fusion/Filter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Filter;\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Filter(p, source) {\n  this.p = p;\n  this.source = source;\n}\n\n/**\n * Create a filtered source, fusing adjacent filter.filter if possible\n * @param {function(x:*):boolean} p filtering predicate\n * @param {{run:function}} source source to filter\n * @returns {Filter} filtered source\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nFilter.create = function createFilter(p, source) {\n  if (source instanceof Filter) {\n    return new Filter(and(source.p, p), source.source);\n  }\n\n  return new Filter(p, source);\n};\n\nFilter.prototype.run = function (sink, scheduler) {\n  return this.source.run(new FilterSink(this.p, sink), scheduler);\n};\n\nfunction FilterSink(p, sink) {\n  this.p = p;\n  this.sink = sink;\n}\n\nFilterSink.prototype.end = _Pipe2.default.prototype.end;\nFilterSink.prototype.error = _Pipe2.default.prototype.error;\n\nFilterSink.prototype.event = function (t, x) {\n  var p = this.p;\n  p(x) && this.sink.event(t, x);\n};\n\nfunction and(p, q) {\n  return function (x) {\n    return p(x) && q(x);\n  };\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/fusion/FilterMap.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = FilterMap;\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction FilterMap(p, f, source) {\n  this.p = p;\n  this.f = f;\n  this.source = source;\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nFilterMap.prototype.run = function (sink, scheduler) {\n  return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler);\n};\n\nfunction FilterMapSink(p, f, sink) {\n  this.p = p;\n  this.f = f;\n  this.sink = sink;\n}\n\nFilterMapSink.prototype.event = function (t, x) {\n  var f = this.f;\n  var p = this.p;\n  p(x) && this.sink.event(t, f(x));\n};\n\nFilterMapSink.prototype.end = _Pipe2.default.prototype.end;\nFilterMapSink.prototype.error = _Pipe2.default.prototype.error;","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/loop.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loop = loop;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @param {Stream} stream event stream\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction loop(stepper, seed, stream) {\n  return new _Stream2.default(new Loop(stepper, seed, stream.source));\n}\n\nfunction Loop(stepper, seed, source) {\n  this.step = stepper;\n  this.seed = seed;\n  this.source = source;\n}\n\nLoop.prototype.run = function (sink, scheduler) {\n  return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler);\n};\n\nfunction LoopSink(stepper, seed, sink) {\n  this.step = stepper;\n  this.seed = seed;\n  this.sink = sink;\n}\n\nLoopSink.prototype.error = _Pipe2.default.prototype.error;\n\nLoopSink.prototype.event = function (t, x) {\n  var result = this.step(this.seed, x);\n  this.seed = result.seed;\n  this.sink.event(t, result.value);\n};\n\nLoopSink.prototype.end = function (t) {\n  this.sink.end(t, this.seed);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/accumulate.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scan = scan;\nexports.reduce = reduce;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _runSource = require('../runSource');\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @param {Stream} stream stream to scan\n * @returns {Stream} new stream containing successive reduce results\n */\nfunction scan(f, initial, stream) {\n  return new _Stream2.default(new Scan(f, initial, stream.source));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction Scan(f, z, source) {\n  this.source = source;\n  this.f = f;\n  this.value = z;\n}\n\nScan.prototype.run = function (sink, scheduler) {\n  var d1 = scheduler.asap(_PropagateTask2.default.event(this.value, sink));\n  var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler);\n  return dispose.all([d1, d2]);\n};\n\nfunction ScanSink(f, z, sink) {\n  this.f = f;\n  this.value = z;\n  this.sink = sink;\n}\n\nScanSink.prototype.event = function (t, x) {\n  var f = this.f;\n  this.value = f(this.value, x);\n  this.sink.event(t, this.value);\n};\n\nScanSink.prototype.error = _Pipe2.default.prototype.error;\nScanSink.prototype.end = _Pipe2.default.prototype.end;\n\n/**\n* Reduce a stream to produce a single result.  Note that reducing an infinite\n* stream will return a Promise that never fulfills, but that may reject if an error\n* occurs.\n* @param {function(result:*, x:*):*} f reducer function\n* @param {*} initial initial value\n* @param {Stream} stream to reduce\n* @returns {Promise} promise for the file result of the reduce\n*/\nfunction reduce(f, initial, stream) {\n  return (0, _runSource.withDefaultScheduler)(new Reduce(f, initial, stream.source));\n}\n\nfunction Reduce(f, z, source) {\n  this.source = source;\n  this.f = f;\n  this.value = z;\n}\n\nReduce.prototype.run = function (sink, scheduler) {\n  return this.source.run(new ReduceSink(this.f, this.value, sink), scheduler);\n};\n\nfunction ReduceSink(f, z, sink) {\n  this.f = f;\n  this.value = z;\n  this.sink = sink;\n}\n\nReduceSink.prototype.event = function (t, x) {\n  var f = this.f;\n  this.value = f(this.value, x);\n  this.sink.event(t, this.value);\n};\n\nReduceSink.prototype.error = _Pipe2.default.prototype.error;\n\nReduceSink.prototype.end = function (t) {\n  this.sink.end(t, this.value);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/build.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cons = cons;\nexports.concat = concat;\n\nvar _core = require('../source/core');\n\nvar _continueWith = require('./continueWith');\n\n/**\n * @param {*} x value to prepend\n * @param {Stream} stream\n * @returns {Stream} new stream with x prepended\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction cons(x, stream) {\n  return concat((0, _core.of)(x), stream);\n}\n\n/**\n* @param {Stream} left\n* @param {Stream} right\n* @returns {Stream} new stream containing all events in left followed by all\n*  events in right.  This *timeshifts* right to the end of left.\n*/\nfunction concat(left, right) {\n  return (0, _continueWith.continueWith)(function () {\n    return right;\n  }, left);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/continueWith.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.continueWith = continueWith;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction continueWith(f, stream) {\n  return new _Stream2.default(new ContinueWith(f, stream.source));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction ContinueWith(f, source) {\n  this.f = f;\n  this.source = source;\n}\n\nContinueWith.prototype.run = function (sink, scheduler) {\n  return new ContinueWithSink(this.f, this.source, sink, scheduler);\n};\n\nfunction ContinueWithSink(f, source, sink, scheduler) {\n  this.f = f;\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.active = true;\n  this.disposable = dispose.once(source.run(this, scheduler));\n}\n\nContinueWithSink.prototype.error = _Pipe2.default.prototype.error;\n\nContinueWithSink.prototype.event = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n  this.sink.event(t, x);\n};\n\nContinueWithSink.prototype.end = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n\n  dispose.tryDispose(t, this.disposable, this.sink);\n  this._startNext(t, x, this.sink);\n};\n\nContinueWithSink.prototype._startNext = function (t, x, sink) {\n  try {\n    this.disposable = this._continue(this.f, x, sink);\n  } catch (e) {\n    sink.error(t, e);\n  }\n};\n\nContinueWithSink.prototype._continue = function (f, x, sink) {\n  return f(x).source.run(sink, this.scheduler);\n};\n\nContinueWithSink.prototype.dispose = function () {\n  this.active = false;\n  return this.disposable.dispose();\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/applicative.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ap = ap;\n\nvar _combine = require('./combine');\n\nvar _prelude = require('@most/prelude');\n\n/**\n * Assume fs is a stream containing functions, and apply the latest function\n * in fs to the latest value in xs.\n * fs:         --f---------g--------h------>\n * xs:         -a-------b-------c-------d-->\n * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->\n * @param {Stream} fs stream of functions to apply to the latest x\n * @param {Stream} xs stream of values to which to apply all the latest f\n * @returns {Stream} stream containing all the applications of fs to xs\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction ap(fs, xs) {\n  return (0, _combine.combine)(_prelude.apply, fs, xs);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/combine.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.combine = combine;\nexports.combineArray = combineArray;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _transform = require('./transform');\n\nvar transform = _interopRequireWildcard(_transform);\n\nvar _core = require('../source/core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _IndexSink = require('../sink/IndexSink');\n\nvar _IndexSink2 = _interopRequireDefault(_IndexSink);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nvar _invoke = require('../invoke');\n\nvar _invoke2 = _interopRequireDefault(_invoke);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar map = base.map;\nvar tail = base.tail;\n\n/**\n * Combine latest events from all input streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nfunction combine(f /*, ...streams */) {\n  return combineArray(f, tail(arguments));\n}\n\n/**\n* Combine latest events from all input streams\n* @param {function(...events):*} f function to combine most recent events\n* @param {[Stream]} streams most recent events\n* @returns {Stream} stream containing the result of applying f to the most recent\n*  event of each input stream, whenever a new event arrives on any stream.\n*/\nfunction combineArray(f, streams) {\n  var l = streams.length;\n  return l === 0 ? core.empty() : l === 1 ? transform.map(f, streams[0]) : new _Stream2.default(combineSources(f, streams));\n}\n\nfunction combineSources(f, streams) {\n  return new Combine(f, map(getSource, streams));\n}\n\nfunction getSource(stream) {\n  return stream.source;\n}\n\nfunction Combine(f, sources) {\n  this.f = f;\n  this.sources = sources;\n}\n\nCombine.prototype.run = function (sink, scheduler) {\n  var this$1 = this;\n\n  var l = this.sources.length;\n  var disposables = new Array(l);\n  var sinks = new Array(l);\n\n  var mergeSink = new CombineSink(disposables, sinks, sink, this.f);\n\n  for (var indexSink, i = 0; i < l; ++i) {\n    indexSink = sinks[i] = new _IndexSink2.default(i, mergeSink);\n    disposables[i] = this$1.sources[i].run(indexSink, scheduler);\n  }\n\n  return dispose.all(disposables);\n};\n\nfunction CombineSink(disposables, sinks, sink, f) {\n  var this$1 = this;\n\n  this.sink = sink;\n  this.disposables = disposables;\n  this.sinks = sinks;\n  this.f = f;\n\n  var l = sinks.length;\n  this.awaiting = l;\n  this.values = new Array(l);\n  this.hasValue = new Array(l);\n  for (var i = 0; i < l; ++i) {\n    this$1.hasValue[i] = false;\n  }\n\n  this.activeCount = sinks.length;\n}\n\nCombineSink.prototype.error = _Pipe2.default.prototype.error;\n\nCombineSink.prototype.event = function (t, indexedValue) {\n  var i = indexedValue.index;\n  var awaiting = this._updateReady(i);\n\n  this.values[i] = indexedValue.value;\n  if (awaiting === 0) {\n    this.sink.event(t, (0, _invoke2.default)(this.f, this.values));\n  }\n};\n\nCombineSink.prototype._updateReady = function (index) {\n  if (this.awaiting > 0) {\n    if (!this.hasValue[index]) {\n      this.hasValue[index] = true;\n      this.awaiting -= 1;\n    }\n  }\n  return this.awaiting;\n};\n\nCombineSink.prototype.end = function (t, indexedValue) {\n  dispose.tryDispose(t, this.disposables[indexedValue.index], this.sink);\n  if (--this.activeCount === 0) {\n    this.sink.end(t, indexedValue.value);\n  }\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/sink/IndexSink.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = IndexSink;\n\nvar _Pipe = require('./Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction IndexSink(i, sink) {\n  this.sink = sink;\n  this.index = i;\n  this.active = true;\n  this.value = void 0;\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nIndexSink.prototype.event = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n  this.value = x;\n  this.sink.event(t, this);\n};\n\nIndexSink.prototype.end = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n  this.active = false;\n  this.sink.end(t, { index: this.index, value: x });\n};\n\nIndexSink.prototype.error = _Pipe2.default.prototype.error;","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/invoke.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = invoke;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction invoke(f, args) {\n  /*eslint complexity: [2,7]*/\n  switch (args.length) {\n    case 0:\n      return f();\n    case 1:\n      return f(args[0]);\n    case 2:\n      return f(args[0], args[1]);\n    case 3:\n      return f(args[0], args[1], args[2]);\n    case 4:\n      return f(args[0], args[1], args[2], args[3]);\n    case 5:\n      return f(args[0], args[1], args[2], args[3], args[4]);\n    default:\n      return f.apply(void 0, args);\n  }\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/transduce.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transduce = transduce;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transform a stream by passing its events through a transducer.\n * @param  {function} transducer transducer function\n * @param  {Stream} stream stream whose events will be passed through the\n *  transducer\n * @return {Stream} stream of events transformed by the transducer\n */\nfunction transduce(transducer, stream) {\n  return new _Stream2.default(new Transduce(transducer, stream.source));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction Transduce(transducer, source) {\n  this.transducer = transducer;\n  this.source = source;\n}\n\nTransduce.prototype.run = function (sink, scheduler) {\n  var xf = this.transducer(new Transformer(sink));\n  return this.source.run(new TransduceSink(getTxHandler(xf), sink), scheduler);\n};\n\nfunction TransduceSink(adapter, sink) {\n  this.xf = adapter;\n  this.sink = sink;\n}\n\nTransduceSink.prototype.event = function (t, x) {\n  var next = this.xf.step(t, x);\n\n  return this.xf.isReduced(next) ? this.sink.end(t, this.xf.getResult(next)) : next;\n};\n\nTransduceSink.prototype.end = function (t, x) {\n  return this.xf.result(x);\n};\n\nTransduceSink.prototype.error = function (t, e) {\n  return this.sink.error(t, e);\n};\n\nfunction Transformer(sink) {\n  this.time = -Infinity;\n  this.sink = sink;\n}\n\nTransformer.prototype['@@transducer/init'] = Transformer.prototype.init = function () {};\n\nTransformer.prototype['@@transducer/step'] = Transformer.prototype.step = function (t, x) {\n  if (!isNaN(t)) {\n    this.time = Math.max(t, this.time);\n  }\n  return this.sink.event(this.time, x);\n};\n\nTransformer.prototype['@@transducer/result'] = Transformer.prototype.result = function (x) {\n  return this.sink.end(this.time, x);\n};\n\n/**\n* Given an object supporting the new or legacy transducer protocol,\n* create an adapter for it.\n* @param {object} tx transform\n* @returns {TxAdapter|LegacyTxAdapter}\n*/\nfunction getTxHandler(tx) {\n  return typeof tx['@@transducer/step'] === 'function' ? new TxAdapter(tx) : new LegacyTxAdapter(tx);\n}\n\n/**\n* Adapter for new official transducer protocol\n* @param {object} tx transform\n* @constructor\n*/\nfunction TxAdapter(tx) {\n  this.tx = tx;\n}\n\nTxAdapter.prototype.step = function (t, x) {\n  return this.tx['@@transducer/step'](t, x);\n};\nTxAdapter.prototype.result = function (x) {\n  return this.tx['@@transducer/result'](x);\n};\nTxAdapter.prototype.isReduced = function (x) {\n  return x != null && x['@@transducer/reduced'];\n};\nTxAdapter.prototype.getResult = function (x) {\n  return x['@@transducer/value'];\n};\n\n/**\n* Adapter for older transducer protocol\n* @param {object} tx transform\n* @constructor\n*/\nfunction LegacyTxAdapter(tx) {\n  this.tx = tx;\n}\n\nLegacyTxAdapter.prototype.step = function (t, x) {\n  return this.tx.step(t, x);\n};\nLegacyTxAdapter.prototype.result = function (x) {\n  return this.tx.result(x);\n};\nLegacyTxAdapter.prototype.isReduced = function (x) {\n  return x != null && x.__transducers_reduced__;\n};\nLegacyTxAdapter.prototype.getResult = function (x) {\n  return x.value;\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/flatMap.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flatMap = flatMap;\nexports.join = join;\n\nvar _mergeConcurrently = require('./mergeConcurrently');\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nfunction flatMap(f, stream) {\n  return (0, _mergeConcurrently.mergeMapConcurrently)(f, Infinity, stream);\n}\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @param {Stream<Stream<X>>} stream stream of streams\n * @returns {Stream<X>} new stream containing all events of all inner streams\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction join(stream) {\n  return (0, _mergeConcurrently.mergeConcurrently)(Infinity, stream);\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/mergeConcurrently.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeConcurrently = mergeConcurrently;\nexports.mergeMapConcurrently = mergeMapConcurrently;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _LinkedList = require('../LinkedList');\n\nvar _LinkedList2 = _interopRequireDefault(_LinkedList);\n\nvar _prelude = require('@most/prelude');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction mergeConcurrently(concurrency, stream) {\n  return mergeMapConcurrently(_prelude.id, concurrency, stream);\n}\n\nfunction mergeMapConcurrently(f, concurrency, stream) {\n  return new _Stream2.default(new MergeConcurrently(f, concurrency, stream.source));\n}\n\nfunction MergeConcurrently(f, concurrency, source) {\n  this.f = f;\n  this.concurrency = concurrency;\n  this.source = source;\n}\n\nMergeConcurrently.prototype.run = function (sink, scheduler) {\n  return new Outer(this.f, this.concurrency, this.source, sink, scheduler);\n};\n\nfunction Outer(f, concurrency, source, sink, scheduler) {\n  this.f = f;\n  this.concurrency = concurrency;\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.pending = [];\n  this.current = new _LinkedList2.default();\n  this.disposable = dispose.once(source.run(this, scheduler));\n  this.active = true;\n}\n\nOuter.prototype.event = function (t, x) {\n  this._addInner(t, x);\n};\n\nOuter.prototype._addInner = function (t, x) {\n  if (this.current.length < this.concurrency) {\n    this._startInner(t, x);\n  } else {\n    this.pending.push(x);\n  }\n};\n\nOuter.prototype._startInner = function (t, x) {\n  try {\n    this._initInner(t, x);\n  } catch (e) {\n    this.error(t, e);\n  }\n};\n\nOuter.prototype._initInner = function (t, x) {\n  var innerSink = new Inner(t, this, this.sink);\n  innerSink.disposable = mapAndRun(this.f, x, innerSink, this.scheduler);\n  this.current.add(innerSink);\n};\n\nfunction mapAndRun(f, x, sink, scheduler) {\n  return f(x).source.run(sink, scheduler);\n}\n\nOuter.prototype.end = function (t, x) {\n  this.active = false;\n  dispose.tryDispose(t, this.disposable, this.sink);\n  this._checkEnd(t, x);\n};\n\nOuter.prototype.error = function (t, e) {\n  this.active = false;\n  this.sink.error(t, e);\n};\n\nOuter.prototype.dispose = function () {\n  this.active = false;\n  this.pending.length = 0;\n  return Promise.all([this.disposable.dispose(), this.current.dispose()]);\n};\n\nOuter.prototype._endInner = function (t, x, inner) {\n  this.current.remove(inner);\n  dispose.tryDispose(t, inner, this);\n\n  if (this.pending.length === 0) {\n    this._checkEnd(t, x);\n  } else {\n    this._startInner(t, this.pending.shift());\n  }\n};\n\nOuter.prototype._checkEnd = function (t, x) {\n  if (!this.active && this.current.isEmpty()) {\n    this.sink.end(t, x);\n  }\n};\n\nfunction Inner(time, outer, sink) {\n  this.prev = this.next = null;\n  this.time = time;\n  this.outer = outer;\n  this.sink = sink;\n  this.disposable = void 0;\n}\n\nInner.prototype.event = function (t, x) {\n  this.sink.event(Math.max(t, this.time), x);\n};\n\nInner.prototype.end = function (t, x) {\n  this.outer._endInner(Math.max(t, this.time), x, this);\n};\n\nInner.prototype.error = function (t, e) {\n  this.outer.error(Math.max(t, this.time), e);\n};\n\nInner.prototype.dispose = function () {\n  return this.disposable.dispose();\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/LinkedList.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = LinkedList;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Doubly linked list\n * @constructor\n */\nfunction LinkedList() {\n  this.head = null;\n  this.length = 0;\n}\n\n/**\n * Add a node to the end of the list\n * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to add\n */\nLinkedList.prototype.add = function (x) {\n  if (this.head !== null) {\n    this.head.prev = x;\n    x.next = this.head;\n  }\n  this.head = x;\n  ++this.length;\n};\n\n/**\n * Remove the provided node from the list\n * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to remove\n */\nLinkedList.prototype.remove = function (x) {\n  // eslint-disable-line  complexity\n  --this.length;\n  if (x === this.head) {\n    this.head = this.head.next;\n  }\n  if (x.next !== null) {\n    x.next.prev = x.prev;\n    x.next = null;\n  }\n  if (x.prev !== null) {\n    x.prev.next = x.next;\n    x.prev = null;\n  }\n};\n\n/**\n * @returns {boolean} true iff there are no nodes in the list\n */\nLinkedList.prototype.isEmpty = function () {\n  return this.length === 0;\n};\n\n/**\n * Dispose all nodes\n * @returns {Promise} promise that fulfills when all nodes have been disposed,\n *  or rejects if an error occurs while disposing\n */\nLinkedList.prototype.dispose = function () {\n  if (this.isEmpty()) {\n    return Promise.resolve();\n  }\n\n  var promises = [];\n  var x = this.head;\n  this.head = null;\n  this.length = 0;\n\n  while (x !== null) {\n    promises.push(x.dispose());\n    x = x.next;\n  }\n\n  return Promise.all(promises);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/concatMap.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concatMap = concatMap;\n\nvar _mergeConcurrently = require('./mergeConcurrently');\n\n/**\n * Map each value in stream to a new stream, and concatenate them all\n * stream:              -a---b---cX\n * f(a):                 1-1-1-1X\n * f(b):                        -2-2-2-2X\n * f(c):                                -3-3-3-3X\n * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X\n * @param {function(x:*):Stream} f function to map each value to a stream\n * @param {Stream} stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nfunction concatMap(f, stream) {\n  return (0, _mergeConcurrently.mergeMapConcurrently)(f, 1, stream);\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/merge.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.merge = merge;\nexports.mergeArray = mergeArray;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _IndexSink = require('../sink/IndexSink');\n\nvar _IndexSink2 = _interopRequireDefault(_IndexSink);\n\nvar _core = require('../source/core');\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar copy = base.copy;\nvar reduce = base.reduce;\n\n/**\n * @returns {Stream} stream containing events from all streams in the argument\n * list in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nfunction merge() /* ...streams*/{\n  return mergeArray(copy(arguments));\n}\n\n/**\n * @param {Array} streams array of stream to merge\n * @returns {Stream} stream containing events from all input observables\n * in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nfunction mergeArray(streams) {\n  var l = streams.length;\n  return l === 0 ? (0, _core.empty)() : l === 1 ? streams[0] : new _Stream2.default(mergeSources(streams));\n}\n\n/**\n * This implements fusion/flattening for merge.  It will\n * fuse adjacent merge operations.  For example:\n * - a.merge(b).merge(c) effectively becomes merge(a, b, c)\n * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)\n * It does this by concatenating the sources arrays of\n * any nested Merge sources, in effect \"flattening\" nested\n * merge operations into a single merge.\n */\nfunction mergeSources(streams) {\n  return new Merge(reduce(appendSources, [], streams));\n}\n\nfunction appendSources(sources, stream) {\n  var source = stream.source;\n  return source instanceof Merge ? sources.concat(source.sources) : sources.concat(source);\n}\n\nfunction Merge(sources) {\n  this.sources = sources;\n}\n\nMerge.prototype.run = function (sink, scheduler) {\n  var this$1 = this;\n\n  var l = this.sources.length;\n  var disposables = new Array(l);\n  var sinks = new Array(l);\n\n  var mergeSink = new MergeSink(disposables, sinks, sink);\n\n  for (var indexSink, i = 0; i < l; ++i) {\n    indexSink = sinks[i] = new _IndexSink2.default(i, mergeSink);\n    disposables[i] = this$1.sources[i].run(indexSink, scheduler);\n  }\n\n  return dispose.all(disposables);\n};\n\nfunction MergeSink(disposables, sinks, sink) {\n  this.sink = sink;\n  this.disposables = disposables;\n  this.activeCount = sinks.length;\n}\n\nMergeSink.prototype.error = _Pipe2.default.prototype.error;\n\nMergeSink.prototype.event = function (t, indexValue) {\n  this.sink.event(t, indexValue.value);\n};\n\nMergeSink.prototype.end = function (t, indexedValue) {\n  dispose.tryDispose(t, this.disposables[indexedValue.index], this.sink);\n  if (--this.activeCount === 0) {\n    this.sink.end(t, indexedValue.value);\n  }\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/sample.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sample = sample;\nexports.sampleWith = sampleWith;\nexports.sampleArray = sampleArray;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nvar _invoke = require('../invoke');\n\nvar _invoke2 = _interopRequireDefault(_invoke);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * When an event arrives on sampler, emit the result of calling f with the latest\n * values of all streams being sampled\n * @param {function(...values):*} f function to apply to each set of sampled values\n * @param {Stream} sampler streams will be sampled whenever an event arrives\n *  on sampler\n * @returns {Stream} stream of sampled and transformed values\n */\nfunction sample(f, sampler /*, ...streams */) {\n  return sampleArray(f, sampler, base.drop(2, arguments));\n}\n\n/**\n * When an event arrives on sampler, emit the latest event value from stream.\n * @param {Stream} sampler stream of events at whose arrival time\n *  stream's latest value will be propagated\n * @param {Stream} stream stream of values\n * @returns {Stream} sampled stream of values\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction sampleWith(sampler, stream) {\n  return new _Stream2.default(new Sampler(base.id, sampler.source, [stream.source]));\n}\n\nfunction sampleArray(f, sampler, streams) {\n  return new _Stream2.default(new Sampler(f, sampler.source, base.map(getSource, streams)));\n}\n\nfunction getSource(stream) {\n  return stream.source;\n}\n\nfunction Sampler(f, sampler, sources) {\n  this.f = f;\n  this.sampler = sampler;\n  this.sources = sources;\n}\n\nSampler.prototype.run = function (sink, scheduler) {\n  var this$1 = this;\n\n  var l = this.sources.length;\n  var disposables = new Array(l + 1);\n  var sinks = new Array(l);\n\n  var sampleSink = new SampleSink(this.f, sinks, sink);\n\n  for (var hold, i = 0; i < l; ++i) {\n    hold = sinks[i] = new Hold(sampleSink);\n    disposables[i] = this$1.sources[i].run(hold, scheduler);\n  }\n\n  disposables[i] = this.sampler.run(sampleSink, scheduler);\n\n  return dispose.all(disposables);\n};\n\nfunction Hold(sink) {\n  this.sink = sink;\n  this.hasValue = false;\n}\n\nHold.prototype.event = function (t, x) {\n  this.value = x;\n  this.hasValue = true;\n  this.sink._notify(this);\n};\n\nHold.prototype.end = function () {};\nHold.prototype.error = _Pipe2.default.prototype.error;\n\nfunction SampleSink(f, sinks, sink) {\n  this.f = f;\n  this.sinks = sinks;\n  this.sink = sink;\n  this.active = false;\n}\n\nSampleSink.prototype._notify = function () {\n  if (!this.active) {\n    this.active = this.sinks.every(hasValue);\n  }\n};\n\nSampleSink.prototype.event = function (t) {\n  if (this.active) {\n    this.sink.event(t, (0, _invoke2.default)(this.f, base.map(getValue, this.sinks)));\n  }\n};\n\nSampleSink.prototype.end = _Pipe2.default.prototype.end;\nSampleSink.prototype.error = _Pipe2.default.prototype.error;\n\nfunction hasValue(hold) {\n  return hold.hasValue;\n}\n\nfunction getValue(hold) {\n  return hold.value;\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/zip.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zip = zip;\nexports.zipArray = zipArray;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _transform = require('./transform');\n\nvar transform = _interopRequireWildcard(_transform);\n\nvar _core = require('../source/core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _IndexSink = require('../sink/IndexSink');\n\nvar _IndexSink2 = _interopRequireDefault(_IndexSink);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _prelude = require('@most/prelude');\n\nvar base = _interopRequireWildcard(_prelude);\n\nvar _invoke = require('../invoke');\n\nvar _invoke2 = _interopRequireDefault(_invoke);\n\nvar _Queue = require('../Queue');\n\nvar _Queue2 = _interopRequireDefault(_Queue);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar map = base.map; /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar tail = base.tail;\n\n/**\n * Combine streams pairwise (or tuple-wise) by index by applying f to values\n * at corresponding indices.  The returned stream ends when any of the input\n * streams ends.\n * @param {function} f function to combine values\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nfunction zip(f /*, ...streams */) {\n  return zipArray(f, tail(arguments));\n}\n\n/**\n* Combine streams pairwise (or tuple-wise) by index by applying f to values\n* at corresponding indices.  The returned stream ends when any of the input\n* streams ends.\n* @param {function} f function to combine values\n* @param {[Stream]} streams streams to zip using f\n* @returns {Stream} new stream with items at corresponding indices combined\n*  using f\n*/\nfunction zipArray(f, streams) {\n  return streams.length === 0 ? core.empty() : streams.length === 1 ? transform.map(f, streams[0]) : new _Stream2.default(new Zip(f, map(getSource, streams)));\n}\n\nfunction getSource(stream) {\n  return stream.source;\n}\n\nfunction Zip(f, sources) {\n  this.f = f;\n  this.sources = sources;\n}\n\nZip.prototype.run = function (sink, scheduler) {\n  var this$1 = this;\n\n  var l = this.sources.length;\n  var disposables = new Array(l);\n  var sinks = new Array(l);\n  var buffers = new Array(l);\n\n  var zipSink = new ZipSink(this.f, buffers, sinks, sink);\n\n  for (var indexSink, i = 0; i < l; ++i) {\n    buffers[i] = new _Queue2.default();\n    indexSink = sinks[i] = new _IndexSink2.default(i, zipSink);\n    disposables[i] = this$1.sources[i].run(indexSink, scheduler);\n  }\n\n  return dispose.all(disposables);\n};\n\nfunction ZipSink(f, buffers, sinks, sink) {\n  this.f = f;\n  this.sinks = sinks;\n  this.sink = sink;\n  this.buffers = buffers;\n}\n\nZipSink.prototype.event = function (t, indexedValue) {\n  // eslint-disable-line complexity\n  var buffers = this.buffers;\n  var buffer = buffers[indexedValue.index];\n\n  buffer.push(indexedValue.value);\n\n  if (buffer.length() === 1) {\n    if (!ready(this.buffers)) {\n      return;\n    }\n\n    emitZipped(this.f, t, buffers, this.sink);\n\n    if (ended(this.buffers, this.sinks)) {\n      this.sink.end(t, void 0);\n    }\n  }\n};\n\nZipSink.prototype.end = function (t, indexedValue) {\n  var buffer = this.buffers[indexedValue.index];\n  if (buffer.isEmpty()) {\n    this.sink.end(t, indexedValue.value);\n  }\n};\n\nZipSink.prototype.error = _Pipe2.default.prototype.error;\n\nfunction emitZipped(f, t, buffers, sink) {\n  sink.event(t, (0, _invoke2.default)(f, map(head, buffers)));\n}\n\nfunction head(buffer) {\n  return buffer.shift();\n}\n\nfunction ended(buffers, sinks) {\n  for (var i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty() && !sinks[i].active) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction ready(buffers) {\n  for (var i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty()) {\n      return false;\n    }\n  }\n  return true;\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/Queue.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Queue;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n// Based on https://github.com/petkaantonov/deque\n\nfunction Queue(capPow2) {\n  this._capacity = capPow2 || 32;\n  this._length = 0;\n  this._head = 0;\n}\n\nQueue.prototype.push = function (x) {\n  var len = this._length;\n  this._checkCapacity(len + 1);\n\n  var i = this._head + len & this._capacity - 1;\n  this[i] = x;\n  this._length = len + 1;\n};\n\nQueue.prototype.shift = function () {\n  var head = this._head;\n  var x = this[head];\n\n  this[head] = void 0;\n  this._head = head + 1 & this._capacity - 1;\n  this._length--;\n  return x;\n};\n\nQueue.prototype.isEmpty = function () {\n  return this._length === 0;\n};\n\nQueue.prototype.length = function () {\n  return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n  if (this._capacity < size) {\n    this._ensureCapacity(this._capacity << 1);\n  }\n};\n\nQueue.prototype._ensureCapacity = function (capacity) {\n  var oldCapacity = this._capacity;\n  this._capacity = capacity;\n\n  var last = this._head + this._length;\n\n  if (last > oldCapacity) {\n    copy(this, 0, this, oldCapacity, last & oldCapacity - 1);\n  }\n};\n\nfunction copy(src, srcIndex, dst, dstIndex, len) {\n  for (var j = 0; j < len; ++j) {\n    dst[j + dstIndex] = src[j + srcIndex];\n    src[j + srcIndex] = void 0;\n  }\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/switch.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.switch = undefined;\nexports.switchLatest = switchLatest;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @param {Stream} stream of streams on which to switch\n * @returns {Stream} switching stream\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction switchLatest(stream) {\n  return new _Stream2.default(new Switch(stream.source));\n}\n\nexports.switch = switchLatest;\n\n\nfunction Switch(source) {\n  this.source = source;\n}\n\nSwitch.prototype.run = function (sink, scheduler) {\n  var switchSink = new SwitchSink(sink, scheduler);\n  return dispose.all([switchSink, this.source.run(switchSink, scheduler)]);\n};\n\nfunction SwitchSink(sink, scheduler) {\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.current = null;\n  this.ended = false;\n}\n\nSwitchSink.prototype.event = function (t, stream) {\n  this._disposeCurrent(t); // TODO: capture the result of this dispose\n  this.current = new Segment(t, Infinity, this, this.sink);\n  this.current.disposable = stream.source.run(this.current, this.scheduler);\n};\n\nSwitchSink.prototype.end = function (t, x) {\n  this.ended = true;\n  this._checkEnd(t, x);\n};\n\nSwitchSink.prototype.error = function (t, e) {\n  this.ended = true;\n  this.sink.error(t, e);\n};\n\nSwitchSink.prototype.dispose = function () {\n  return this._disposeCurrent(this.scheduler.now());\n};\n\nSwitchSink.prototype._disposeCurrent = function (t) {\n  if (this.current !== null) {\n    return this.current._dispose(t);\n  }\n};\n\nSwitchSink.prototype._disposeInner = function (t, inner) {\n  inner._dispose(t); // TODO: capture the result of this dispose\n  if (inner === this.current) {\n    this.current = null;\n  }\n};\n\nSwitchSink.prototype._checkEnd = function (t, x) {\n  if (this.ended && this.current === null) {\n    this.sink.end(t, x);\n  }\n};\n\nSwitchSink.prototype._endInner = function (t, x, inner) {\n  this._disposeInner(t, inner);\n  this._checkEnd(t, x);\n};\n\nSwitchSink.prototype._errorInner = function (t, e, inner) {\n  this._disposeInner(t, inner);\n  this.sink.error(t, e);\n};\n\nfunction Segment(min, max, outer, sink) {\n  this.min = min;\n  this.max = max;\n  this.outer = outer;\n  this.sink = sink;\n  this.disposable = dispose.empty();\n}\n\nSegment.prototype.event = function (t, x) {\n  if (t < this.max) {\n    this.sink.event(Math.max(t, this.min), x);\n  }\n};\n\nSegment.prototype.end = function (t, x) {\n  this.outer._endInner(Math.max(t, this.min), x, this);\n};\n\nSegment.prototype.error = function (t, e) {\n  this.outer._errorInner(Math.max(t, this.min), e, this);\n};\n\nSegment.prototype._dispose = function (t) {\n  this.max = t;\n  dispose.tryDispose(t, this.disposable, this.sink);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/filter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filter = filter;\nexports.skipRepeats = skipRepeats;\nexports.skipRepeatsWith = skipRepeatsWith;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _Filter = require('../fusion/Filter');\n\nvar _Filter2 = _interopRequireDefault(_Filter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Retain only items matching a predicate\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @param {Stream} stream stream to filter\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\nfunction filter(p, stream) {\n  return new _Stream2.default(_Filter2.default.create(p, stream.source));\n}\n\n/**\n * Skip repeated events, using === to detect duplicates\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction skipRepeats(stream) {\n  return skipRepeatsWith(same, stream);\n}\n\n/**\n * Skip repeated events using the provided equals function to detect duplicates\n * @param {function(a:*, b:*):boolean} equals optional function to compare items\n * @param {Stream} stream stream from which to omit repeated events\n * @returns {Stream} stream without repeated events\n */\nfunction skipRepeatsWith(equals, stream) {\n  return new _Stream2.default(new SkipRepeats(equals, stream.source));\n}\n\nfunction SkipRepeats(equals, source) {\n  this.equals = equals;\n  this.source = source;\n}\n\nSkipRepeats.prototype.run = function (sink, scheduler) {\n  return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler);\n};\n\nfunction SkipRepeatsSink(equals, sink) {\n  this.equals = equals;\n  this.sink = sink;\n  this.value = void 0;\n  this.init = true;\n}\n\nSkipRepeatsSink.prototype.end = _Pipe2.default.prototype.end;\nSkipRepeatsSink.prototype.error = _Pipe2.default.prototype.error;\n\nSkipRepeatsSink.prototype.event = function (t, x) {\n  if (this.init) {\n    this.init = false;\n    this.value = x;\n    this.sink.event(t, x);\n  } else if (!this.equals(this.value, x)) {\n    this.value = x;\n    this.sink.event(t, x);\n  }\n};\n\nfunction same(a, b) {\n  return a === b;\n}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/slice.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.take = take;\nexports.skip = skip;\nexports.slice = slice;\nexports.takeWhile = takeWhile;\nexports.skipWhile = skipWhile;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _core = require('../source/core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _Map = require('../fusion/Map');\n\nvar _Map2 = _interopRequireDefault(_Map);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream containing only up to the first n items from stream\n */\nfunction take(n, stream) {\n  return slice(0, n, stream);\n}\n\n/**\n * @param {number} n\n * @param {Stream} stream\n * @returns {Stream} new stream with the first n items removed\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction skip(n, stream) {\n  return slice(n, Infinity, stream);\n}\n\n/**\n * Slice a stream by index. Negative start/end indexes are not supported\n * @param {number} start\n * @param {number} end\n * @param {Stream} stream\n * @returns {Stream} stream containing items where start <= index < end\n */\nfunction slice(start, end, stream) {\n  return end <= start ? core.empty() : new _Stream2.default(sliceSource(start, end, stream.source));\n}\n\nfunction sliceSource(start, end, source) {\n  return source instanceof _Map2.default ? commuteMapSlice(start, end, source) : source instanceof Slice ? fuseSlice(start, end, source) : new Slice(start, end, source);\n}\n\nfunction commuteMapSlice(start, end, source) {\n  return _Map2.default.create(source.f, sliceSource(start, end, source.source));\n}\n\nfunction fuseSlice(start, end, source) {\n  start += source.min;\n  end = Math.min(end + source.min, source.max);\n  return new Slice(start, end, source.source);\n}\n\nfunction Slice(min, max, source) {\n  this.source = source;\n  this.min = min;\n  this.max = max;\n}\n\nSlice.prototype.run = function (sink, scheduler) {\n  return new SliceSink(this.min, this.max - this.min, this.source, sink, scheduler);\n};\n\nfunction SliceSink(skip, take, source, sink, scheduler) {\n  this.sink = sink;\n  this.skip = skip;\n  this.take = take;\n  this.disposable = dispose.once(source.run(this, scheduler));\n}\n\nSliceSink.prototype.end = _Pipe2.default.prototype.end;\nSliceSink.prototype.error = _Pipe2.default.prototype.error;\n\nSliceSink.prototype.event = function (t, x) {\n  // eslint-disable-line complexity\n  if (this.skip > 0) {\n    this.skip -= 1;\n    return;\n  }\n\n  if (this.take === 0) {\n    return;\n  }\n\n  this.take -= 1;\n  this.sink.event(t, x);\n  if (this.take === 0) {\n    this.dispose();\n    this.sink.end(t, x);\n  }\n};\n\nSliceSink.prototype.dispose = function () {\n  return this.disposable.dispose();\n};\n\nfunction takeWhile(p, stream) {\n  return new _Stream2.default(new TakeWhile(p, stream.source));\n}\n\nfunction TakeWhile(p, source) {\n  this.p = p;\n  this.source = source;\n}\n\nTakeWhile.prototype.run = function (sink, scheduler) {\n  return new TakeWhileSink(this.p, this.source, sink, scheduler);\n};\n\nfunction TakeWhileSink(p, source, sink, scheduler) {\n  this.p = p;\n  this.sink = sink;\n  this.active = true;\n  this.disposable = dispose.once(source.run(this, scheduler));\n}\n\nTakeWhileSink.prototype.end = _Pipe2.default.prototype.end;\nTakeWhileSink.prototype.error = _Pipe2.default.prototype.error;\n\nTakeWhileSink.prototype.event = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n\n  var p = this.p;\n  this.active = p(x);\n  if (this.active) {\n    this.sink.event(t, x);\n  } else {\n    this.dispose();\n    this.sink.end(t, x);\n  }\n};\n\nTakeWhileSink.prototype.dispose = function () {\n  return this.disposable.dispose();\n};\n\nfunction skipWhile(p, stream) {\n  return new _Stream2.default(new SkipWhile(p, stream.source));\n}\n\nfunction SkipWhile(p, source) {\n  this.p = p;\n  this.source = source;\n}\n\nSkipWhile.prototype.run = function (sink, scheduler) {\n  return this.source.run(new SkipWhileSink(this.p, sink), scheduler);\n};\n\nfunction SkipWhileSink(p, sink) {\n  this.p = p;\n  this.sink = sink;\n  this.skipping = true;\n}\n\nSkipWhileSink.prototype.end = _Pipe2.default.prototype.end;\nSkipWhileSink.prototype.error = _Pipe2.default.prototype.error;\n\nSkipWhileSink.prototype.event = function (t, x) {\n  if (this.skipping) {\n    var p = this.p;\n    this.skipping = p(x);\n    if (this.skipping) {\n      return;\n    }\n  }\n\n  this.sink.event(t, x);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/timeslice.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.takeUntil = takeUntil;\nexports.skipUntil = skipUntil;\nexports.during = during;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _flatMap = require('../combinator/flatMap');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction takeUntil(signal, stream) {\n  return new _Stream2.default(new Until(signal.source, stream.source));\n}\n\nfunction skipUntil(signal, stream) {\n  return new _Stream2.default(new Since(signal.source, stream.source));\n}\n\nfunction during(timeWindow, stream) {\n  return takeUntil((0, _flatMap.join)(timeWindow), skipUntil(timeWindow, stream));\n}\n\nfunction Until(maxSignal, source) {\n  this.maxSignal = maxSignal;\n  this.source = source;\n}\n\nUntil.prototype.run = function (sink, scheduler) {\n  var min = new Bound(-Infinity, sink);\n  var max = new UpperBound(this.maxSignal, sink, scheduler);\n  var disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);\n\n  return dispose.all([min, max, disposable]);\n};\n\nfunction Since(minSignal, source) {\n  this.minSignal = minSignal;\n  this.source = source;\n}\n\nSince.prototype.run = function (sink, scheduler) {\n  var min = new LowerBound(this.minSignal, sink, scheduler);\n  var max = new Bound(Infinity, sink);\n  var disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);\n\n  return dispose.all([min, max, disposable]);\n};\n\nfunction Bound(value, sink) {\n  this.value = value;\n  this.sink = sink;\n}\n\nBound.prototype.error = _Pipe2.default.prototype.error;\nBound.prototype.event = noop;\nBound.prototype.end = noop;\nBound.prototype.dispose = noop;\n\nfunction TimeWindowSink(min, max, sink) {\n  this.min = min;\n  this.max = max;\n  this.sink = sink;\n}\n\nTimeWindowSink.prototype.event = function (t, x) {\n  if (t >= this.min.value && t < this.max.value) {\n    this.sink.event(t, x);\n  }\n};\n\nTimeWindowSink.prototype.error = _Pipe2.default.prototype.error;\nTimeWindowSink.prototype.end = _Pipe2.default.prototype.end;\n\nfunction LowerBound(signal, sink, scheduler) {\n  this.value = Infinity;\n  this.sink = sink;\n  this.disposable = signal.run(this, scheduler);\n}\n\nLowerBound.prototype.event = function (t /*, x */) {\n  if (t < this.value) {\n    this.value = t;\n  }\n};\n\nLowerBound.prototype.end = noop;\nLowerBound.prototype.error = _Pipe2.default.prototype.error;\n\nLowerBound.prototype.dispose = function () {\n  return this.disposable.dispose();\n};\n\nfunction UpperBound(signal, sink, scheduler) {\n  this.value = Infinity;\n  this.sink = sink;\n  this.disposable = signal.run(this, scheduler);\n}\n\nUpperBound.prototype.event = function (t, x) {\n  if (t < this.value) {\n    this.value = t;\n    this.sink.end(t, x);\n  }\n};\n\nUpperBound.prototype.end = noop;\nUpperBound.prototype.error = _Pipe2.default.prototype.error;\n\nUpperBound.prototype.dispose = function () {\n  return this.disposable.dispose();\n};\n\nfunction noop() {}","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/delay.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.delay = delay;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @param {Stream} stream\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction delay(delayTime, stream) {\n  return delayTime <= 0 ? stream : new _Stream2.default(new Delay(delayTime, stream.source));\n}\n\nfunction Delay(dt, source) {\n  this.dt = dt;\n  this.source = source;\n}\n\nDelay.prototype.run = function (sink, scheduler) {\n  var delaySink = new DelaySink(this.dt, sink, scheduler);\n  return dispose.all([delaySink, this.source.run(delaySink, scheduler)]);\n};\n\nfunction DelaySink(dt, sink, scheduler) {\n  this.dt = dt;\n  this.sink = sink;\n  this.scheduler = scheduler;\n}\n\nDelaySink.prototype.dispose = function () {\n  var self = this;\n  this.scheduler.cancelAll(function (task) {\n    return task.sink === self.sink;\n  });\n};\n\nDelaySink.prototype.event = function (t, x) {\n  this.scheduler.delay(this.dt, _PropagateTask2.default.event(x, this.sink));\n};\n\nDelaySink.prototype.end = function (t, x) {\n  this.scheduler.delay(this.dt, _PropagateTask2.default.end(x, this.sink));\n};\n\nDelaySink.prototype.error = _Pipe2.default.prototype.error;","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/timestamp.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.timestamp = timestamp;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction timestamp(stream) {\n  return new _Stream2.default(new Timestamp(stream.source));\n}\n\nfunction Timestamp(source) {\n  this.source = source;\n}\n\nTimestamp.prototype.run = function (sink, scheduler) {\n  return this.source.run(new TimestampSink(sink), scheduler);\n};\n\nfunction TimestampSink(sink) {\n  this.sink = sink;\n}\n\nTimestampSink.prototype.end = _Pipe2.default.prototype.end;\nTimestampSink.prototype.error = _Pipe2.default.prototype.error;\n\nTimestampSink.prototype.event = function (t, x) {\n  this.sink.event(t, { time: t, value: x });\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/limit.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.throttle = throttle;\nexports.debounce = debounce;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _Pipe = require('../sink/Pipe');\n\nvar _Pipe2 = _interopRequireDefault(_Pipe);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nvar _Map = require('../fusion/Map');\n\nvar _Map2 = _interopRequireDefault(_Map);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Limit the rate of events by suppressing events that occur too often\n * @param {Number} period time to suppress events\n * @param {Stream} stream\n * @returns {Stream}\n */\nfunction throttle(period, stream) {\n  return new _Stream2.default(throttleSource(period, stream.source));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction throttleSource(period, source) {\n  return source instanceof _Map2.default ? commuteMapThrottle(period, source) : source instanceof Throttle ? fuseThrottle(period, source) : new Throttle(period, source);\n}\n\nfunction commuteMapThrottle(period, source) {\n  return _Map2.default.create(source.f, throttleSource(period, source.source));\n}\n\nfunction fuseThrottle(period, source) {\n  return new Throttle(Math.max(period, source.period), source.source);\n}\n\nfunction Throttle(period, source) {\n  this.period = period;\n  this.source = source;\n}\n\nThrottle.prototype.run = function (sink, scheduler) {\n  return this.source.run(new ThrottleSink(this.period, sink), scheduler);\n};\n\nfunction ThrottleSink(period, sink) {\n  this.time = 0;\n  this.period = period;\n  this.sink = sink;\n}\n\nThrottleSink.prototype.event = function (t, x) {\n  if (t >= this.time) {\n    this.time = t + this.period;\n    this.sink.event(t, x);\n  }\n};\n\nThrottleSink.prototype.end = _Pipe2.default.prototype.end;\n\nThrottleSink.prototype.error = _Pipe2.default.prototype.error;\n\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * @param {Number} period events occuring more frequently than this\n *  will be suppressed\n * @param {Stream} stream stream to debounce\n * @returns {Stream} new debounced stream\n */\nfunction debounce(period, stream) {\n  return new _Stream2.default(new Debounce(period, stream.source));\n}\n\nfunction Debounce(dt, source) {\n  this.dt = dt;\n  this.source = source;\n}\n\nDebounce.prototype.run = function (sink, scheduler) {\n  return new DebounceSink(this.dt, this.source, sink, scheduler);\n};\n\nfunction DebounceSink(dt, source, sink, scheduler) {\n  this.dt = dt;\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.value = void 0;\n  this.timer = null;\n\n  var sourceDisposable = source.run(this, scheduler);\n  this.disposable = dispose.all([this, sourceDisposable]);\n}\n\nDebounceSink.prototype.event = function (t, x) {\n  this._clearTimer();\n  this.value = x;\n  this.timer = this.scheduler.delay(this.dt, _PropagateTask2.default.event(x, this.sink));\n};\n\nDebounceSink.prototype.end = function (t, x) {\n  if (this._clearTimer()) {\n    this.sink.event(t, this.value);\n    this.value = void 0;\n  }\n  this.sink.end(t, x);\n};\n\nDebounceSink.prototype.error = function (t, x) {\n  this._clearTimer();\n  this.sink.error(t, x);\n};\n\nDebounceSink.prototype.dispose = function () {\n  this._clearTimer();\n};\n\nDebounceSink.prototype._clearTimer = function () {\n  if (this.timer === null) {\n    return false;\n  }\n  this.timer.dispose();\n  this.timer = null;\n  return true;\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/promises.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromPromise = fromPromise;\nexports.awaitPromises = awaitPromises;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _fatalError = require('../fatalError');\n\nvar _fatalError2 = _interopRequireDefault(_fatalError);\n\nvar _core = require('../source/core');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a stream containing only the promise's fulfillment\n * value at the time it fulfills.\n * @param {Promise<T>} p promise\n * @return {Stream<T>} stream containing promise's fulfillment value.\n *  If the promise rejects, the stream will error\n */\nfunction fromPromise(p) {\n  return awaitPromises((0, _core.of)(p));\n}\n\n/**\n * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.\n * Event order is preserved.\n * @param {Stream<Promise<T>>} stream\n * @return {Stream<T>} stream of fulfillment values.  The stream will\n * error if any promise rejects.\n */\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction awaitPromises(stream) {\n  return new _Stream2.default(new Await(stream.source));\n}\n\nfunction Await(source) {\n  this.source = source;\n}\n\nAwait.prototype.run = function (sink, scheduler) {\n  return this.source.run(new AwaitSink(sink, scheduler), scheduler);\n};\n\nfunction AwaitSink(sink, scheduler) {\n  this.sink = sink;\n  this.scheduler = scheduler;\n  this.queue = Promise.resolve();\n  var self = this;\n\n  // Pre-create closures, to avoid creating them per event\n  this._eventBound = function (x) {\n    self.sink.event(self.scheduler.now(), x);\n  };\n\n  this._endBound = function (x) {\n    self.sink.end(self.scheduler.now(), x);\n  };\n\n  this._errorBound = function (e) {\n    self.sink.error(self.scheduler.now(), e);\n  };\n}\n\nAwaitSink.prototype.event = function (t, promise) {\n  var self = this;\n  this.queue = this.queue.then(function () {\n    return self._event(promise);\n  }).catch(this._errorBound);\n};\n\nAwaitSink.prototype.end = function (t, x) {\n  var self = this;\n  this.queue = this.queue.then(function () {\n    return self._end(x);\n  }).catch(this._errorBound);\n};\n\nAwaitSink.prototype.error = function (t, e) {\n  var self = this;\n  // Don't resolve error values, propagate directly\n  this.queue = this.queue.then(function () {\n    return self._errorBound(e);\n  }).catch(_fatalError2.default);\n};\n\nAwaitSink.prototype._event = function (promise) {\n  return promise.then(this._eventBound);\n};\n\nAwaitSink.prototype._end = function (x) {\n  return Promise.resolve(x).then(this._endBound);\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/combinator/errors.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flatMapError = undefined;\nexports.recoverWith = recoverWith;\nexports.throwError = throwError;\n\nvar _Stream = require('../Stream');\n\nvar _Stream2 = _interopRequireDefault(_Stream);\n\nvar _SafeSink = require('../sink/SafeSink');\n\nvar _SafeSink2 = _interopRequireDefault(_SafeSink);\n\nvar _dispose = require('../disposable/dispose');\n\nvar dispose = _interopRequireWildcard(_dispose);\n\nvar _tryEvent = require('../source/tryEvent');\n\nvar tryEvent = _interopRequireWildcard(_tryEvent);\n\nvar _PropagateTask = require('../scheduler/PropagateTask');\n\nvar _PropagateTask2 = _interopRequireDefault(_PropagateTask);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * If stream encounters an error, recover and continue with items from stream\n * returned by f.\n * @param {function(error:*):Stream} f function which returns a new stream\n * @param {Stream} stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\nfunction recoverWith(f, stream) {\n  return new _Stream2.default(new RecoverWith(f, stream.source));\n} /** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar flatMapError = exports.flatMapError = recoverWith;\n\n/**\n * Create a stream containing only an error\n * @param {*} e error value, preferably an Error or Error subtype\n * @returns {Stream} new stream containing only an error\n */\nfunction throwError(e) {\n  return new _Stream2.default(new ErrorSource(e));\n}\n\nfunction ErrorSource(e) {\n  this.value = e;\n}\n\nErrorSource.prototype.run = function (sink, scheduler) {\n  return scheduler.asap(new _PropagateTask2.default(runError, this.value, sink));\n};\n\nfunction runError(t, e, sink) {\n  sink.error(t, e);\n}\n\nfunction RecoverWith(f, source) {\n  this.f = f;\n  this.source = source;\n}\n\nRecoverWith.prototype.run = function (sink, scheduler) {\n  return new RecoverWithSink(this.f, this.source, sink, scheduler);\n};\n\nfunction RecoverWithSink(f, source, sink, scheduler) {\n  this.f = f;\n  this.sink = new _SafeSink2.default(sink);\n  this.scheduler = scheduler;\n  this.disposable = source.run(this, scheduler);\n}\n\nRecoverWithSink.prototype.event = function (t, x) {\n  tryEvent.tryEvent(t, x, this.sink);\n};\n\nRecoverWithSink.prototype.end = function (t, x) {\n  tryEvent.tryEnd(t, x, this.sink);\n};\n\nRecoverWithSink.prototype.error = function (t, e) {\n  var nextSink = this.sink.disable();\n\n  dispose.tryDispose(t, this.disposable, this.sink);\n  this._startNext(t, e, nextSink);\n};\n\nRecoverWithSink.prototype._startNext = function (t, x, sink) {\n  try {\n    this.disposable = this._continue(this.f, x, sink);\n  } catch (e) {\n    sink.error(t, e);\n  }\n};\n\nRecoverWithSink.prototype._continue = function (f, x, sink) {\n  var stream = f(x);\n  return stream.source.run(sink, this.scheduler);\n};\n\nRecoverWithSink.prototype.dispose = function () {\n  return this.disposable.dispose();\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/lib/sink/SafeSink.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = SafeSink;\n/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nfunction SafeSink(sink) {\n  this.sink = sink;\n  this.active = true;\n}\n\nSafeSink.prototype.event = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n  this.sink.event(t, x);\n};\n\nSafeSink.prototype.end = function (t, x) {\n  if (!this.active) {\n    return;\n  }\n  this.disable();\n  this.sink.end(t, x);\n};\n\nSafeSink.prototype.error = function (t, e) {\n  this.disable();\n  this.sink.error(t, e);\n};\n\nSafeSink.prototype.disable = function () {\n  this.active = false;\n  return this.sink;\n};","/home/travis/build/npmtest/node-npmtest-most/node_modules/most/src/index.js":"/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Stream from './Stream'\nimport * as base from '@most/prelude'\nimport { of, empty, never } from './source/core'\nimport { from } from './source/from'\nimport { periodic } from './source/periodic'\nimport symbolObservable from 'symbol-observable'\n\n/**\n * Core stream type\n * @type {Stream}\n */\nexport { Stream }\n\n// Add of and empty to constructor for fantasy-land compat\nStream.of = of\nStream.empty = empty\n// Add from to constructor for ES Observable compat\nStream.from = from\nexport { of, of as just, empty, never, from, periodic }\n\n// -----------------------------------------------------------------------\n// Draft ES Observable proposal interop\n// https://github.com/zenparsing/es-observable\n\nimport { subscribe } from './observable/subscribe'\n\nStream.prototype.subscribe = function (subscriber) {\n  return subscribe(subscriber, this)\n}\n\nStream.prototype[symbolObservable] = function () {\n  return this\n}\n\n// -----------------------------------------------------------------------\n// Fluent adapter\n\nimport { thru } from './combinator/thru'\n\n/**\n * Adapt a functional stream transform to fluent style.\n * It applies f to the this stream object\n * @param  {function(s: Stream): Stream} f function that\n * receives the stream itself and must return a new stream\n * @return {Stream}\n */\nStream.prototype.thru = function (f) {\n  return thru(f, this)\n}\n\n// -----------------------------------------------------------------------\n// Adapting other sources\n\n/**\n * Create a stream of events from the supplied EventTarget or EventEmitter\n * @param {String} event event name\n * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter. The source\n *  must support either addEventListener/removeEventListener (w3c EventTarget:\n *  http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget),\n *  or addListener/removeListener (node EventEmitter: http://nodejs.org/api/events.html)\n * @returns {Stream} stream of events of the specified type from the source\n */\nexport { fromEvent } from './source/fromEvent'\n\n// -----------------------------------------------------------------------\n// Observing\n\nimport { observe, drain } from './combinator/observe'\n\nexport { observe, observe as forEach, drain }\n\n/**\n * Process all the events in the stream\n * @returns {Promise} promise that fulfills when the stream ends, or rejects\n *  if the stream fails with an unhandled error.\n */\nStream.prototype.observe = Stream.prototype.forEach = function (f) {\n  return observe(f, this)\n}\n\n/**\n * Consume all events in the stream, without providing a function to process each.\n * This causes a stream to become active and begin emitting events, and is useful\n * in cases where all processing has been setup upstream via other combinators, and\n * there is no need to process the terminal events.\n * @returns {Promise} promise that fulfills when the stream ends, or rejects\n *  if the stream fails with an unhandled error.\n */\nStream.prototype.drain = function () {\n  return drain(this)\n}\n\n// -------------------------------------------------------\n\nimport { loop } from './combinator/loop'\n\nexport { loop }\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function\n * @param {*} seed initial seed value passed to first stepper call\n * @returns {Stream} new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nStream.prototype.loop = function (stepper, seed) {\n  return loop(stepper, seed, this)\n}\n\n// -------------------------------------------------------\n\nimport { scan, reduce } from './combinator/accumulate'\n\nexport { scan, reduce }\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial initial value\n * @returns {Stream} new stream containing successive reduce results\n */\nStream.prototype.scan = function (f, initial) {\n  return scan(f, initial, this)\n}\n\n/**\n * Reduce the stream to produce a single result.  Note that reducing an infinite\n * stream will return a Promise that never fulfills, but that may reject if an error\n * occurs.\n * @param {function(result:*, x:*):*} f reducer function\n * @param {*} initial optional initial value\n * @returns {Promise} promise for the file result of the reduce\n */\nStream.prototype.reduce = function (f, initial) {\n  return reduce(f, initial, this)\n}\n\n// -----------------------------------------------------------------------\n// Building and extending\n\nexport { unfold } from './source/unfold'\nexport { iterate } from './source/iterate'\nexport { generate } from './source/generate'\nimport { concat, cons as startWith } from './combinator/build'\n\nexport { concat, startWith }\n\n/**\n * @param {Stream} tail\n * @returns {Stream} new stream containing all items in this followed by\n *  all items in tail\n */\nStream.prototype.concat = function (tail) {\n  return concat(this, tail)\n}\n\n/**\n * @param {*} x value to prepend\n * @returns {Stream} a new stream with x prepended\n */\nStream.prototype.startWith = function (x) {\n  return startWith(x, this)\n}\n\n// -----------------------------------------------------------------------\n// Transforming\n\nimport { map, constant, tap } from './combinator/transform'\nimport { ap } from './combinator/applicative'\n\nexport { map, constant, tap, ap }\n\n/**\n * Transform each value in the stream by applying f to each\n * @param {function(*):*} f mapping function\n * @returns {Stream} stream containing items transformed by f\n */\nStream.prototype.map = function (f) {\n  return map(f, this)\n}\n\n/**\n * Assume this stream contains functions, and apply each function to each item\n * in the provided stream.  This generates, in effect, a cross product.\n * @param {Stream} xs stream of items to which\n * @returns {Stream} stream containing the cross product of items\n */\nStream.prototype.ap = function (xs) {\n  return ap(this, xs)\n}\n\n/**\n * Replace each value in the stream with x\n * @param {*} x\n * @returns {Stream} stream containing items replaced with x\n */\nStream.prototype.constant = function (x) {\n  return constant(x, this)\n}\n\n/**\n * Perform a side effect for each item in the stream\n * @param {function(x:*):*} f side effect to execute for each item. The\n *  return value will be discarded.\n * @returns {Stream} new stream containing the same items as this stream\n */\nStream.prototype.tap = function (f) {\n  return tap(f, this)\n}\n\n// -----------------------------------------------------------------------\n// Transducer support\n\nimport { transduce } from './combinator/transduce'\n\nexport { transduce }\n\n/**\n * Transform this stream by passing its events through a transducer.\n * @param  {function} transducer transducer function\n * @return {Stream} stream of events transformed by the transducer\n */\nStream.prototype.transduce = function (transducer) {\n  return transduce(transducer, this)\n}\n\n// -----------------------------------------------------------------------\n// FlatMapping\n\nimport { flatMap, join } from './combinator/flatMap'\n\n// @deprecated flatMap, use chain instead\nexport { flatMap, flatMap as chain, join }\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param {function(x:*):Stream} f chaining function, must return a Stream\n * @returns {Stream} new stream containing all events from each stream returned by f\n */\nStream.prototype.chain = function (f) {\n  return flatMap(f, this)\n}\n\n// @deprecated use chain instead\nStream.prototype.flatMap = Stream.prototype.chain\n\n  /**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @returns {Stream<X>} new stream containing all events of all inner streams\n */\nStream.prototype.join = function () {\n  return join(this)\n}\n\nimport { continueWith } from './combinator/continueWith'\n\n// @deprecated flatMapEnd, use continueWith instead\nexport { continueWith, continueWith as flatMapEnd }\n\n/**\n * Map the end event to a new stream, and begin emitting its values.\n * @param {function(x:*):Stream} f function that receives the end event value,\n * and *must* return a new Stream to continue with.\n * @returns {Stream} new stream that emits all events from the original stream,\n * followed by all events from the stream returned by f.\n */\nStream.prototype.continueWith = function (f) {\n  return continueWith(f, this)\n}\n\n// @deprecated use continueWith instead\nStream.prototype.flatMapEnd = Stream.prototype.continueWith\n\nimport { concatMap } from './combinator/concatMap'\n\nexport { concatMap }\n\nStream.prototype.concatMap = function (f) {\n  return concatMap(f, this)\n}\n\n// -----------------------------------------------------------------------\n// Concurrent merging\n\nimport { mergeConcurrently } from './combinator/mergeConcurrently'\n\nexport { mergeConcurrently }\n\n/**\n * Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer, limiting the number of inner streams that may\n * be active concurrently.\n * @param {number} concurrency at most this many inner streams will be\n *  allowed to be active concurrently.\n * @return {Stream<X>} new stream containing all events of all inner\n *  streams, with limited concurrency.\n */\nStream.prototype.mergeConcurrently = function (concurrency) {\n  return mergeConcurrently(concurrency, this)\n}\n\n// -----------------------------------------------------------------------\n// Merging\n\nimport { merge, mergeArray } from './combinator/merge'\n\nexport { merge, mergeArray }\n\n/**\n * Merge this stream and all the provided streams\n * @returns {Stream} stream containing items from this stream and s in time\n * order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nStream.prototype.merge = function (/* ...streams*/) {\n  return mergeArray(base.cons(this, arguments))\n}\n\n// -----------------------------------------------------------------------\n// Combining\n\nimport { combine, combineArray } from './combinator/combine'\n\nexport { combine, combineArray }\n\n/**\n * Combine latest events from all input streams\n * @param {function(...events):*} f function to combine most recent events\n * @returns {Stream} stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nStream.prototype.combine = function (f /*, ...streams*/) {\n  return combineArray(f, base.replace(this, 0, arguments))\n}\n\n// -----------------------------------------------------------------------\n// Sampling\n\nimport { sample, sampleArray, sampleWith } from './combinator/sample'\n\nexport { sample, sampleArray, sampleWith }\n\n/**\n * When an event arrives on sampler, emit the latest event value from stream.\n * @param {Stream} sampler stream of events at whose arrival time\n *  signal's latest value will be propagated\n * @returns {Stream} sampled stream of values\n */\nStream.prototype.sampleWith = function (sampler) {\n  return sampleWith(sampler, this)\n}\n\n/**\n * When an event arrives on this stream, emit the result of calling f with the latest\n * values of all streams being sampled\n * @param {function(...values):*} f function to apply to each set of sampled values\n * @returns {Stream} stream of sampled and transformed values\n */\nStream.prototype.sample = function (f /* ...streams */) {\n  return sampleArray(f, this, base.tail(arguments))\n}\n\n// -----------------------------------------------------------------------\n// Zipping\n\nimport { zip, zipArray } from './combinator/zip'\n\nexport { zip, zipArray }\n\n/**\n * Pair-wise combine items with those in s. Given 2 streams:\n * [1,2,3] zipWith f [4,5,6] -> [f(1,4),f(2,5),f(3,6)]\n * Note: zip causes fast streams to buffer and wait for slow streams.\n * @param {function(a:Stream, b:Stream, ...):*} f function to combine items\n * @returns {Stream} new stream containing pairs\n */\nStream.prototype.zip = function (f /*, ...streams*/) {\n  return zipArray(f, base.replace(this, 0, arguments))\n}\n\n// -----------------------------------------------------------------------\n// Switching\n\nimport { switchLatest } from './combinator/switch'\n\n// @deprecated switch, use switchLatest instead\nexport { switchLatest, switchLatest as switch }\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @returns {Stream} switching stream\n */\nStream.prototype.switchLatest = function () {\n  return switchLatest(this)\n}\n\n// @deprecated use switchLatest instead\nStream.prototype.switch = Stream.prototype.switchLatest\n\n// -----------------------------------------------------------------------\n// Filtering\n\nimport { filter, skipRepeats, skipRepeatsWith } from './combinator/filter'\n\n// @deprecated distinct, use skipRepeats instead\n// @deprecated distinctBy, use skipRepeatsWith instead\nexport { filter, skipRepeats, skipRepeats as distinct, skipRepeatsWith, skipRepeatsWith as distinctBy }\n\n/**\n * Retain only items matching a predicate\n * stream:                           -12345678-\n * filter(x => x % 2 === 0, stream): --2-4-6-8-\n * @param {function(x:*):boolean} p filtering predicate called for each item\n * @returns {Stream} stream containing only items for which predicate returns truthy\n */\nStream.prototype.filter = function (p) {\n  return filter(p, this)\n}\n\n/**\n * Skip repeated events, using === to compare items\n * stream:           -abbcd-\n * distinct(stream): -ab-cd-\n * @returns {Stream} stream with no repeated events\n */\nStream.prototype.skipRepeats = function () {\n  return skipRepeats(this)\n}\n\n/**\n * Skip repeated events, using supplied equals function to compare items\n * @param {function(a:*, b:*):boolean} equals function to compare items\n * @returns {Stream} stream with no repeated events\n */\nStream.prototype.skipRepeatsWith = function (equals) {\n  return skipRepeatsWith(equals, this)\n}\n\n// -----------------------------------------------------------------------\n// Slicing\n\nimport { take, skip, slice, takeWhile, skipWhile } from './combinator/slice'\n\nexport { take, skip, slice, takeWhile, skipWhile }\n\n/**\n * stream:          -abcd-\n * take(2, stream): -ab|\n * @param {Number} n take up to this many events\n * @returns {Stream} stream containing at most the first n items from this stream\n */\nStream.prototype.take = function (n) {\n  return take(n, this)\n}\n\n/**\n * stream:          -abcd->\n * skip(2, stream): ---cd->\n * @param {Number} n skip this many events\n * @returns {Stream} stream not containing the first n events\n */\nStream.prototype.skip = function (n) {\n  return skip(n, this)\n}\n\n/**\n * Slice a stream by event index. Equivalent to, but more efficient than\n * stream.take(end).skip(start);\n * NOTE: Negative start and end are not supported\n * @param {Number} start skip all events before the start index\n * @param {Number} end allow all events from the start index to the end index\n * @returns {Stream} stream containing items where start <= index < end\n */\nStream.prototype.slice = function (start, end) {\n  return slice(start, end, this)\n}\n\n/**\n * stream:                        -123451234->\n * takeWhile(x => x < 5, stream): -1234|\n * @param {function(x:*):boolean} p predicate\n * @returns {Stream} stream containing items up to, but not including, the\n * first item for which p returns falsy.\n */\nStream.prototype.takeWhile = function (p) {\n  return takeWhile(p, this)\n}\n\n/**\n * stream:                        -123451234->\n * skipWhile(x => x < 5, stream): -----51234->\n * @param {function(x:*):boolean} p predicate\n * @returns {Stream} stream containing items following *and including* the\n * first item for which p returns falsy.\n */\nStream.prototype.skipWhile = function (p) {\n  return skipWhile(p, this)\n}\n\n// -----------------------------------------------------------------------\n// Time slicing\n\nimport { takeUntil, skipUntil, during } from './combinator/timeslice'\n\n// @deprecated takeUntil, use until instead\n// @deprecated skipUntil, use since instead\nexport { takeUntil, takeUntil as until, skipUntil, skipUntil as since, during }\n\n/**\n * stream:                    -a-b-c-d-e-f-g->\n * signal:                    -------x\n * takeUntil(signal, stream): -a-b-c-|\n * @param {Stream} signal retain only events in stream before the first\n * event in signal\n * @returns {Stream} new stream containing only events that occur before\n * the first event in signal.\n */\nStream.prototype.until = function (signal) {\n  return takeUntil(signal, this)\n}\n\n// @deprecated use until instead\nStream.prototype.takeUntil = Stream.prototype.until\n\n  /**\n * stream:                    -a-b-c-d-e-f-g->\n * signal:                    -------x\n * takeUntil(signal, stream): -------d-e-f-g->\n * @param {Stream} signal retain only events in stream at or after the first\n * event in signal\n * @returns {Stream} new stream containing only events that occur after\n * the first event in signal.\n */\nStream.prototype.since = function (signal) {\n  return skipUntil(signal, this)\n}\n\n// @deprecated use since instead\nStream.prototype.skipUntil = Stream.prototype.since\n\n  /**\n * stream:                    -a-b-c-d-e-f-g->\n * timeWindow:                -----s\n * s:                               -----t\n * stream.during(timeWindow): -----c-d-e-|\n * @param {Stream<Stream>} timeWindow a stream whose first event (s) represents\n *  the window start time.  That event (s) is itself a stream whose first event (t)\n *  represents the window end time\n * @returns {Stream} new stream containing only events within the provided timespan\n */\nStream.prototype.during = function (timeWindow) {\n  return during(timeWindow, this)\n}\n\n// -----------------------------------------------------------------------\n// Delaying\n\nimport { delay } from './combinator/delay'\n\nexport { delay }\n\n/**\n * @param {Number} delayTime milliseconds to delay each item\n * @returns {Stream} new stream containing the same items, but delayed by ms\n */\nStream.prototype.delay = function (delayTime) {\n  return delay(delayTime, this)\n}\n\n// -----------------------------------------------------------------------\n// Getting event timestamp\n\nimport { timestamp } from './combinator/timestamp'\nexport { timestamp }\n\n/**\n * Expose event timestamps into the stream. Turns a Stream<X> into\n * Stream<{time:t, value:X}>\n * @returns {Stream<{time:number, value:*}>}\n */\nStream.prototype.timestamp = function () {\n  return timestamp(this)\n}\n\n// -----------------------------------------------------------------------\n// Rate limiting\n\nimport { throttle, debounce } from './combinator/limit'\n\nexport { throttle, debounce }\n\n/**\n * Limit the rate of events\n * stream:              abcd----abcd----\n * throttle(2, stream): a-c-----a-c-----\n * @param {Number} period time to suppress events\n * @returns {Stream} new stream that skips events for throttle period\n */\nStream.prototype.throttle = function (period) {\n  return throttle(period, this)\n}\n\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * stream:              abcd----abcd----\n * debounce(2, stream): -----d-------d--\n * @param {Number} period events occuring more frequently than this\n *  on the provided scheduler will be suppressed\n * @returns {Stream} new debounced stream\n */\nStream.prototype.debounce = function (period) {\n  return debounce(period, this)\n}\n\n// -----------------------------------------------------------------------\n// Awaiting Promises\n\nimport { fromPromise, awaitPromises } from './combinator/promises'\n\n// @deprecated await, use awaitPromises instead\nexport { fromPromise, awaitPromises, awaitPromises as await }\n\n/**\n * Await promises, turning a Stream<Promise<X>> into Stream<X>.  Preserves\n * event order, but timeshifts events based on promise resolution time.\n * @returns {Stream<X>} stream containing non-promise values\n */\nStream.prototype.awaitPromises = function () {\n  return awaitPromises(this)\n}\n\n// @deprecated use awaitPromises instead\nStream.prototype.await = Stream.prototype.awaitPromises\n\n// -----------------------------------------------------------------------\n// Error handling\n\nimport { recoverWith, flatMapError, throwError } from './combinator/errors'\n\n// @deprecated flatMapError, use recoverWith instead\nexport { recoverWith, flatMapError, throwError }\n\n/**\n * If this stream encounters an error, recover and continue with items from stream\n * returned by f.\n * stream:                  -a-b-c-X-\n * f(X):                           d-e-f-g-\n * flatMapError(f, stream): -a-b-c-d-e-f-g-\n * @param {function(error:*):Stream} f function which returns a new stream\n * @returns {Stream} new stream which will recover from an error by calling f\n */\nStream.prototype.recoverWith = function (f) {\n  return flatMapError(f, this)\n}\n\n// @deprecated use recoverWith instead\nStream.prototype.flatMapError = Stream.prototype.recoverWith\n\n// -----------------------------------------------------------------------\n// Multicasting\n\nimport multicast from '@most/multicast'\n\nexport { multicast }\n\n/**\n * Transform the stream into multicast stream.  That means that many subscribers\n * to the stream will not cause multiple invocations of the internal machinery.\n * @returns {Stream} new stream which will multicast events to all observers.\n */\nStream.prototype.multicast = function () {\n  return multicast(this)\n}\n\n// export the instance of the defaultScheduler for third-party libraries\nimport defaultScheduler from './scheduler/defaultScheduler'\n\nexport { defaultScheduler }\n\n// export an implementation of Task used internally for third-party libraries\nimport PropagateTask from './scheduler/PropagateTask'\n\nexport { PropagateTask }\n"}